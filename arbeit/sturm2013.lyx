#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
\usepackage{lmodern} 
\usepackage{xcolor}
\colorlet{chapter}{black!75}
%\addtokomafont{chapter}{\color{chapter}}

\usepackage{multicol}

\usepackage{hyperref}
\hypersetup{pdfborder=0 0 0} 

% prevent orphans and widdow
\tolerance 1414
\hbadness 1414
\emergencystretch 1.5em
\hfuzz 0.3pt
\clubpenalty = 10000
\widowpenalty = 10000
\vfuzz \hfuzz
\raggedbottom

% packages for graphics and figgures
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{fit}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{shapes,snakes}

\usetikzlibrary{%
  arrows,%
  shapes.misc,% wg. rounded rectangle
  shapes.arrows,%
  chains,%
  matrix,%
  positioning,% wg. " of "
  scopes,%
  decorations.pathmorphing,% /pgf/decoration/random steps | erste Graphik
  shadows%
}

% smaller margin comments
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\tiny #1]%
{\raggedright\tiny #1}}

%definition of source code highlighting and coloring
\definecolor{chocolate3}{HTML}{8F5902}
\definecolor{skyBlue3}{HTML}{204A87}
\definecolor{plum1}{HTML}{AD7FA8}
\definecolor{plum2}{HTML}{75507B}
\definecolor{plum3}{HTML}{5C3566}
\definecolor{chameleon3}{HTML}{4E9A06}
\definecolor{scarletRed3}{HTML}{A40000}
\definecolor{aluminium4}{HTML}{888A85}
\lstdefinelanguage{ReActor}
{
   alsoletter={-},
   columns=fixed,
   keywordstyle=[1]{\color{plum2}\bfseries},
   keywordstyle=[2]{\color{chocolate3}\bfseries},
   keywordstyle=[3]{\color{chameleon3}\bfseries},
   keywordstyle=[4]{\color{skyBlue3}\bfseries},
   commentstyle={\color{aluminium4}\itshape},
   stringstyle={\color{scarletRed3}\bfseries},
   morekeywords=[1]{}, % neccessary for otherkeywords
   otherkeywords={(,)},
   morekeywords=
[2]{constant,constants,variable,variables,assume,acquaintances,invariant,init-predicate,events,event,self,true,false},
   morekeywords=[3]{new},
   morekeywords=[4]{send,operations,operation},
   sensitive=false,
   morecomment=[l]{;},
   morestring=[b]",
} 
\lstdefinelanguage{EBNF}
{
   columns=fixed,
   alsoletter={=,|,(,),[,],\{,\},+,},
   keywordstyle=[1]{\color{chocolate3}\bfseries},
   keywordstyle=[2]{\color{chameleon3}\bfseries},
   commentstyle={\color{aluminium4}\itshape},
   stringstyle={\color{scarletRed3}\bfseries},
   morekeywords=[1]{|,(,),[,],\{,\},+,},
   otherkeywords={[,],\{,\}},
   morekeywords=[2]{=},
   sensitive=false,
   morecomment=[s]{(*}{*)},
   morestring=[b]",
} 

%%%%%%%%%%%%%%%%%%%%%%%% start of tlatex.sty file %%%%%%%%%%%%%%%%%%%%%%% 
\usepackage{color}
\definecolor{boxshade}{gray}{0.85}
\setlength{\textwidth}{360pt}
\setlength{\textheight}{541pt}
\usepackage{latexsym}
\usepackage{ifthen}
% \usepackage{color}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SWITCHES                                                                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newboolean{shading} 
\setboolean{shading}{false}
\makeatletter
 %% this is needed only when inserted into the file, not when
 %% used as a package file.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                           %
% DEFINITIONS OF SYMBOL-PRODUCING COMMANDS                                  %
%                                                                           %
%    TLA+      LaTeX                                                        %
%    symbol    command                                                      %
%    ------    -------                                                      %
%    =>        \implies                                                     %
%    <:        \ltcolon                                                     %
%    :>        \colongt                                                     %
%    ==        \defeq                                                       %
%    ..        \dotdot                                                      %
%    ::        \coloncolon                                                  %
%    =|        \eqdash                                                      %
%    ++        \pp                                                          %
%    --        \mm                                                          %
%    **        \stst                                                        %
%    //        \slsl                                                        %
%    ^         \ct                                                          %
%    \A        \A                                                           %
%    \E        \E                                                           %
%    \AA       \AA                                                          %
%    \EE       \EE                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\symlength}
\newcommand{\implies}{\Rightarrow}
\newcommand{\ltcolon}{\mathrel{<\!\!\mbox{:}}}
\newcommand{\colongt}{\mathrel{\!\mbox{:}\!\!>}}
\newcommand{\defeq}{\;\mathrel{\smash   %% keep this symbol from being too tall
    {{\stackrel{\scriptscriptstyle\Delta}{=}}}}\;}
\newcommand{\dotdot}{\mathrel{\ldotp\ldotp}}
\newcommand{\coloncolon}{\mathrel{::\;}}
\newcommand{\eqdash}{\mathrel = \joinrel \hspace{-.28em}|}
\newcommand{\pp}{\mathbin{++}}
\newcommand{\mm}{\mathbin{--}}
\newcommand{\stst}{*\!*}
\newcommand{\slsl}{/\!/}
\newcommand{\ct}{\hat{\hspace{.4em}}}
\newcommand{\A}{\forall}
\newcommand{\E}{\exists}
\renewcommand{\AA}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
   $\forall\hspace{-.517em}\forall\hspace{-.517em}\forall$}}%
   \forall\hspace{-.517em}\forall \hspace{-.517em}\forall\,$}}
\newcommand{\EE}{\makebox{$\raisebox{.05em}{\makebox[0pt][l]{%
   $\exists\hspace{-.517em}\exists\hspace{-.517em}\exists$}}%
   \exists\hspace{-.517em}\exists\hspace{-.517em}\exists\,$}}
\newcommand{\whileop}{\.{\stackrel
  {\mbox{\raisebox{-.3em}[0pt][0pt]{$\scriptscriptstyle+\;\,$}}}%
  {-\hspace{-.16em}\triangleright}}}

% Commands are defined to produce the upper-case keywords.
% Note that some have space after them.
\newcommand{\ASSUME}{\textsc{assume }}
\newcommand{\ASSUMPTION}{\textsc{assumption }}
\newcommand{\AXIOM}{\textsc{axiom }}
\newcommand{\BOOLEAN}{\textsc{boolean }}
\newcommand{\CASE}{\textsc{case }}
\newcommand{\CONSTANT}{\textsc{constant }}
\newcommand{\CONSTANTS}{\textsc{constants }}
\newcommand{\ELSE}{\settowidth{\symlength}{\THEN}%
   \makebox[\symlength][l]{\textsc{ else}}}
\newcommand{\EXCEPT}{\textsc{ except }}
\newcommand{\EXTENDS}{\textsc{extends }}
\newcommand{\FALSE}{\textsc{false}}
\newcommand{\IF}{\textsc{if }}
\newcommand{\IN}{\settowidth{\symlength}{\LET}%
   \makebox[\symlength][l]{\textsc{in}}}
\newcommand{\INSTANCE}{\textsc{instance }}
\newcommand{\LET}{\textsc{let }}
\newcommand{\LOCAL}{\textsc{local }}
\newcommand{\MODULE}{\textsc{module }}
\newcommand{\OTHER}{\textsc{other }}
\newcommand{\STRING}{\textsc{string}}
\newcommand{\THEN}{\textsc{ then }}
\newcommand{\THEOREM}{\textsc{theorem }}
\newcommand{\LEMMA}{\textsc{lemma }}
\newcommand{\PROPOSITION}{\textsc{proposition }}
\newcommand{\COROLLARY}{\textsc{corollary }}
\newcommand{\TRUE}{\textsc{true}}
\newcommand{\VARIABLE}{\textsc{variable }}
\newcommand{\VARIABLES}{\textsc{variables }}
\newcommand{\WITH}{\textsc{ with }}
\newcommand{\WF}{\textrm{WF}}
\newcommand{\SF}{\textrm{SF}}
\newcommand{\CHOOSE}{\textsc{choose }}
\newcommand{\ENABLED}{\textsc{enabled }}
\newcommand{\UNCHANGED}{\textsc{unchanged }}
\newcommand{\SUBSET}{\textsc{subset }}
\newcommand{\UNION}{\textsc{union }}
\newcommand{\DOMAIN}{\textsc{domain }}
% Added for tla2tex
\newcommand{\BY}{\textsc{by }}
\newcommand{\OBVIOUS}{\textsc{obvious }}
\newcommand{\HAVE}{\textsc{have }}
\newcommand{\QED}{\textsc{qed }}
\newcommand{\TAKE}{\textsc{take }}
\newcommand{\DEF}{\textsc{ def }}
\newcommand{\HIDE}{\textsc{hide }}
\newcommand{\RECURSIVE}{\textsc{recursive }}
\newcommand{\USE}{\textsc{use }}
\newcommand{\DEFINE}{\textsc{define }}
\newcommand{\PROOF}{\textsc{proof }}
\newcommand{\WITNESS}{\textsc{witness }}
\newcommand{\PICK}{\textsc{pick }}
\newcommand{\DEFS}{\textsc{defs }}
\newcommand{\PROVE}{\settowidth{\symlength}{\ASSUME}%
   \makebox[\symlength][l]{\textsc{prove}}\@s{-4.1}}%
  %% The \@s{-4.1) is a kludge added on 24 Oct 2009 [happy birthday, Ellen]
  %% so the correct alignment occurs if the user types
  %%   ASSUME X
  %%   PROVE  Y
  %% because it cancels the extra 4.1 pts added because of the 
  %% extra space after the PROVE.  This seems to works OK.
  %% However, the 4.1 equals Parameters.LaTeXLeftSpace(1) and
  %% should be changed if that method ever changes.
\newcommand{\SUFFICES}{\textsc{suffices }}
\newcommand{\NEW}{\textsc{new }}
\newcommand{\LAMBDA}{\textsc{lambda }}
\newcommand{\STATE}{\textsc{state }}
\newcommand{\ACTION}{\textsc{action }}
\newcommand{\TEMPORAL}{\textsc{temporal }}
\newcommand{\ONLY}{\textsc{only }}              %% added by LL on 2 Oct 2009
\newcommand{\OMITTED}{\textsc{omitted }}        %% added by LL on 31 Oct 2009
\newcommand{\@pfstepnum}[2]{\ensuremath{\langle#1\rangle}\textrm{#2}}
\newcommand{\bang}{\@s{1}\mbox{\small !}\@s{1}}
%% We should format || differently in PlusCal code than in TLA+ formulas.
\newcommand{\p@barbar}{\ifpcalsymbols
   \,\,\rule[-.25em]{.075em}{1em}\hspace*{.2em}\rule[-.25em]{.075em}{1em}\,\,%
   \else \,||\,\fi}
%% PlusCal keywords
\newcommand{\p@fair}{\textbf{fair }}
\newcommand{\p@semicolon}{\textbf{\,; }}
\newcommand{\p@algorithm}{\textbf{algorithm }}
\newcommand{\p@mmfair}{\textbf{-{}-fair }}
\newcommand{\p@mmalgorithm}{\textbf{-{}-algorithm }}
\newcommand{\p@assert}{\textbf{assert }}
\newcommand{\p@await}{\textbf{await }}
\newcommand{\p@begin}{\textbf{begin }}
\newcommand{\p@end}{\textbf{end }}
\newcommand{\p@call}{\textbf{call }}
\newcommand{\p@define}{\textbf{define }}
\newcommand{\p@do}{\textbf{ do }}
\newcommand{\p@either}{\textbf{either }}
\newcommand{\p@or}{\textbf{or }}
\newcommand{\p@goto}{\textbf{goto }}
\newcommand{\p@if}{\textbf{if }}
\newcommand{\p@then}{\,\,\textbf{then }}
\newcommand{\p@else}{\ifcsyntax \textbf{else } \else \,\,\textbf{else }\fi}
\newcommand{\p@elsif}{\,\,\textbf{elsif }}
\newcommand{\p@macro}{\textbf{macro }}
\newcommand{\p@print}{\textbf{print }}
\newcommand{\p@procedure}{\textbf{procedure }}
\newcommand{\p@process}{\textbf{process }}
\newcommand{\p@return}{\textbf{return}}
\newcommand{\p@skip}{\textbf{skip}}
\newcommand{\p@variable}{\textbf{variable }}
\newcommand{\p@variables}{\textbf{variables }}
\newcommand{\p@while}{\textbf{while }}
\newcommand{\p@when}{\textbf{when }}
\newcommand{\p@with}{\textbf{with }}
\newcommand{\p@lparen}{\textbf{(\,\,}}
\newcommand{\p@rparen}{\textbf{\,\,) }}   
\newcommand{\p@lbrace}{\textbf{\{\,\,}}   
\newcommand{\p@rbrace}{\textbf{\,\,\} }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REDEFINE STANDARD COMMANDS TO MAKE THEM FORMAT BETTER %
%                                                       %
% We redefine \in and \notin                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\_}{\rule{.4em}{.06em}\hspace{.05em}}
\newlength{\equalswidth}
\let\oldin=\in
\let\oldnotin=\notin
\renewcommand{\in}{%
   {\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth][c]{$\oldin$}}}
\renewcommand{\notin}{%
   {\settowidth{\equalswidth}{$\.{=}$}\makebox[\equalswidth]{$\oldnotin$}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                  %
% HORIZONTAL BARS:                                 %
%                                                  %
%   \moduleLeftDash    |~~~~~~~~~~                 %
%   \moduleRightDash    ~~~~~~~~~~|                %
%   \midbar            |----------|                %
%   \bottombar         |__________|                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\charwidth}\settowidth{\charwidth}{{\small\tt M}}
\newlength{\boxrulewd}\setlength{\boxrulewd}{.4pt}
\newlength{\boxlineht}\setlength{\boxlineht}{.5\baselineskip}
\newcommand{\boxsep}{\charwidth}
\newlength{\boxruleht}\setlength{\boxruleht}{.5ex}
\newlength{\boxruledp}\setlength{\boxruledp}{-\boxruleht}
\addtolength{\boxruledp}{\boxrulewd}
\newcommand{\boxrule}{\leaders\hrule height \boxruleht depth \boxruledp
                      \hfill\mbox{}}
\newcommand{\@computerule}{%
  \setlength{\boxruleht}{.5ex}%
  \setlength{\boxruledp}{-\boxruleht}%
  \addtolength{\boxruledp}{\boxrulewd}}

\newcommand{\bottombar}{\hspace{-\boxsep}%
  \raisebox{-\boxrulewd}[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}%
  \boxrule
  \raisebox{-\boxrulewd}[0pt][0pt]{%
      \rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}\vspace{0pt}}

\newcommand{\moduleLeftDash}%
   {\hspace*{-\boxsep}%
     \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
               }{\boxlineht}}%
    \boxrule\hspace*{.4em }}

\newcommand{\moduleRightDash}%
    {\hspace*{.4em}\boxrule
    \raisebox{-\boxlineht}[0pt][0pt]{\rule[.5ex]{\boxrulewd
               }{\boxlineht}}\hspace{-\boxsep}}%\vspace{.2em}

\newcommand{\midbar}{\hspace{-\boxsep}\raisebox{-.5\boxlineht}[0pt][0pt]{%
   \rule[.5ex]{\boxrulewd}{\boxlineht}}\boxrule\raisebox{-.5\boxlineht%
   }[0pt][0pt]{\rule[.5ex]{\boxrulewd}{\boxlineht}}\hspace{-\boxsep}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FORMATING COMMANDS                                                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PLUSCAL SHADING                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The TeX pcalshading switch is set on to cause PlusCal shading to be
% performed.  This changes the behavior of the following commands and
% environments to cause full-width shading to be performed on all lines.
% 
%   \tstrut \@x cpar mcom \@pvspace
% 
% The TeX pcalsymbols switch is turned on when typesetting a PlusCal algorithm,
% whether or not shading is being performed.  It causes symbols (other than
% parentheses and braces and PlusCal-only keywords) that should be typeset
% differently depending on whether they are in an algorithm to be typeset
% appropriately.  Currently, the only such symbol is "||".
%
% The TeX csyntax switch is turned on when typesetting a PlusCal algorithm in
% c-syntax.  This allows symbols to be format differently in the two syntaxes.
% The "else" keyword is the only one that is.

\newif\ifpcalshading \pcalshadingfalse
\newif\ifpcalsymbols \pcalsymbolsfalse
\newif\ifcsyntax     \csyntaxfalse

% The \@pvspace command makes a vertical space.  It uses \vspace
% except with \ifpcalshading, in which case it sets \pvcalvspace
% and the space is added by a following \@x command.
%
\newlength{\pcalvspace}\setlength{\pcalvspace}{0pt}%
\newcommand{\@pvspace}[1]{%
  \ifpcalshading
     \par\global\setlength{\pcalvspace}{#1}%
  \else
     \par\vspace{#1}%
  \fi
}

% The lcom environment was changed to set \lcomindent equal to
% the indentation it produces.  This length is used by the
% cpar environment to make shading extend for the full width
% of the line.  This assumes that lcom environments are not
% nested.  I hope TLATeX does not nest them.
%
\newlength{\lcomindent}%
\setlength{\lcomindent}{0pt}%

%\tstrut: A strut to produce inter-paragraph space in a comment.
%\rstrut: A strut to extend the bottom of a one-line comment so
%         there's no break in the shading between comments on 
%         successive lines.
\newcommand\tstrut%
  {\raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{1.15em}}}%
   \global\setlength{\vshadelen}{0pt}}
\newcommand\rstrut{\raisebox{-.25em}{\rule{0pt}{1.15em}}%
 \global\setlength{\vshadelen}{0pt}}


% \.{op} formats operator op in math mode with empty boxes on either side.
% Used because TeX otherwise vary the amount of space it leaves around op.
\renewcommand{\.}[1]{\ensuremath{\mbox{}#1\mbox{}}}

% \@s{n} produces an n-point space
\newcommand{\@s}[1]{\hspace{#1pt}}           

% \@x{txt} starts a specification line in the beginning with txt
% in the final LaTeX source.
\newlength{\@xlen}
\newcommand\xtstrut%
  {\setlength{\@xlen}{1.05em}%
   \addtolength{\@xlen}{\pcalvspace}%
    \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\@xlen}}}%
   \global\setlength{\vshadelen}{0pt}%
   \global\setlength{\pcalvspace}{0pt}}

\newcommand{\@x}[1]{\par
  \ifpcalshading
  \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
  \fi
  \mbox{$\mbox{}#1\mbox{}$}}  

% \@xx{txt} continues a specification line with the text txt.
\newcommand{\@xx}[1]{\mbox{$\mbox{}#1\mbox{}$}}  

% \@y{cmt} produces a one-line comment.
\newcommand{\@y}[1]{\mbox{\footnotesize\hspace{.65em}%
  \ifthenelse{\boolean{shading}}{%
      \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
               {#1\hspace{-\the\lastskip}\rstrut}}}

% \@z{cmt} produces a zero-width one-line comment.
\newcommand{\@z}[1]{\makebox[0pt][l]{\footnotesize
  \ifthenelse{\boolean{shading}}{%
      \shadebox{#1\hspace{-\the\lastskip}\rstrut}}%
               {#1\hspace{-\the\lastskip}\rstrut}}}


% \@w{str} produces the TLA+ string "str".
\newcommand{\@w}[1]{\textsf{``{#1}''}}             


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SHADING                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\graymargin{1}
  % The number of points of margin in the shaded box.

% \definecolor{boxshade}{gray}{.85}
% Defines the darkness of the shading: 1 = white, 0 = black
% Added by TLATeX only if needed.

% \shadebox{txt} puts txt in a shaded box.
\newlength{\templena}
\newlength{\templenb}
\newsavebox{\tempboxa}
\newcommand{\shadebox}[1]{{\setlength{\fboxsep}{\graymargin pt}%
     \savebox{\tempboxa}{#1}%
     \settoheight{\templena}{\usebox{\tempboxa}}%
     \settodepth{\templenb}{\usebox{\tempboxa}}%
     \hspace*{-\fboxsep}\raisebox{0pt}[\templena][\templenb]%
        {\colorbox{boxshade}{\usebox{\tempboxa}}}\hspace*{-\fboxsep}}}

% \vshade{n} makes an n-point inter-paragraph space, with
%  shading if the `shading' flag is true.
\newlength{\vshadelen}
\setlength{\vshadelen}{0pt}
\newcommand{\vshade}[1]{\ifthenelse{\boolean{shading}}%
   {\global\setlength{\vshadelen}{#1pt}}%
   {\vspace{#1pt}}}

\newlength{\boxwidth}
\newlength{\multicommentdepth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE cpar ENVIRONMENT                                                      %
% ^^^^^^^^^^^^^^^^^^^^                                                      %
% The LaTeX input                                                           %
%                                                                           %
%   \begin{cpar}{pop}{nest}{isLabel}{d}{e}{arg6}                            %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%     XXXXXXXXXXXXXXX                                                       %
%   \end{cpar}                                                              %
%                                                                           %
% produces one of two possible results.  If isLabel is the letter "T",      %
% it produces the following, where [label] is the result of typesetting     %
% arg6 in an LR box, and d is is a number representing a distance in        %
% points.                                                                   %
%                                                                           %
%   prevailing |<-- d -->[label]<- e ->XXXXXXXXXXXXXXX                      %
%         left |                       XXXXXXXXXXXXXXX                      %
%       margin |                       XXXXXXXXXXXXXXX                      %
%                                                                           %
% If isLabel is the letter "F", then it produces                            %
%                                                                           %
%   prevailing |<-- d -->XXXXXXXXXXXXXXXXXXXXXXX                            %
%         left |         <- e ->XXXXXXXXXXXXXXXX                            %
%       margin |                XXXXXXXXXXXXXXXX                            %
%                                                                           %
% where d and e are numbers representing distances in points.               %
%                                                                           %
% The prevailing left margin is the one in effect before the most recent    %
% pop (argument 1) cpar environments with "T" as the nest argument, where   %
% pop is a number \geq 0.                                                   %
%                                                                           %
% If the nest argument is the letter "T", then the prevailing left          %
% margin is moved to the left of the second (and following) lines of        %
% X's.  Otherwise, the prevailing left margin is left unchanged.            %
%                                                                           %
% An \unnest{n} command moves the prevailing left margin to where it was    %
% before the most recent n cpar environments with "T" as the nesting        %
% argument.                                                                 %
%                                                                           %
% The environment leaves no vertical space above or below it, or between    %
% its paragraphs.  (TLATeX inserts the proper amount of vertical space.)    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcounter{pardepth}
\setcounter{pardepth}{0}

% \setgmargin{txt} defines \gmarginN to be txt, where N is \roman{pardepth}.
% \thegmargin equals \gmarginN, where N is \roman{pardepth}.
\newcommand{\setgmargin}[1]{%
  \expandafter\xdef\csname gmargin\roman{pardepth}\endcsname{#1}}
\newcommand{\thegmargin}{\csname gmargin\roman{pardepth}\endcsname}
\newcommand{\gmargin}{0pt}

\newsavebox{\tempsbox}

\newlength{\@cparht}
\newlength{\@cpardp}
\newenvironment{cpar}[6]{%
  \addtocounter{pardepth}{-#1}%
  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
                                 \begin{minipage}[t]{\linewidth}}{}%
  \begin{list}{}{%
     \edef\temp{\thegmargin}
     \ifthenelse{\equal{#3}{T}}%
       {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
        \addtolength{\leftmargin}{#4pt}}%
       {\setlength{\leftmargin}{#4pt}%
        \addtolength{\leftmargin}{#5pt}%
        \addtolength{\leftmargin}{\temp}%
        \setlength{\itemindent}{-#5pt}}%
      \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
                                 \setgmargin{\the\leftmargin}}{}%
      \setlength{\labelwidth}{0pt}%
      \setlength{\labelsep}{0pt}%
      \setlength{\itemindent}{-\leftmargin}%
      \setlength{\topsep}{0pt}%
      \setlength{\parsep}{0pt}%
      \setlength{\partopsep}{0pt}%
      \setlength{\parskip}{0pt}%
      \setlength{\itemsep}{0pt}
      \setlength{\itemindent}{#4pt}%
      \addtolength{\itemindent}{-\leftmargin}}%
   \ifthenelse{\equal{#3}{T}}%
      {\item[\tstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]
        }%
      {\item[\tstrut\hspace{\temp}]%
         }%
   \footnotesize}
 {\hspace{-\the\lastskip}\tstrut
 \end{list}%
  \ifthenelse{\boolean{shading}}%
          {\end{minipage}%
           \end{lrbox}%
           \ifpcalshading
             \setlength{\@cparht}{\ht\tempsbox}%
             \setlength{\@cpardp}{\dp\tempsbox}%
             \addtolength{\@cparht}{.15em}%
             \addtolength{\@cpardp}{.2em}%
             \addtolength{\@cparht}{\@cpardp}%
            % I don't know what's going on here.  I want to add a
            % \pcalvspace high shaded line, but I don't know how to
            % do it.  A little trial and error shows that the following
            % does a reasonable job approximating that, eliminating
            % the line if \pcalvspace is small.
            \addtolength{\@cparht}{\pcalvspace}%
             \ifdim \pcalvspace > .8em
               \addtolength{\pcalvspace}{-.2em}%
               \hspace*{-\lcomindent}%
               \shadebox{\rule{0pt}{\pcalvspace}\hspace*{\textwidth}}\par
               \global\setlength{\pcalvspace}{0pt}%
               \fi
             \hspace*{-\lcomindent}%
             \makebox[0pt][l]{\raisebox{-\@cpardp}[0pt][0pt]{%
                 \shadebox{\rule{0pt}{\@cparht}\hspace*{\textwidth}}}}%
             \hspace*{\lcomindent}\usebox{\tempsbox}%
             \par
           \else
             \shadebox{\usebox{\tempsbox}}\par
           \fi}%
           {}%
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE ppar ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% The environment                                                            %
%                                                                            %
%   \begin{ppar} ... \end{ppar}                                              %
%                                                                            %
% is equivalent to                                                           %
%                                                                            %
%   \begin{cpar}{0}{F}{F}{0}{0}{} ... \end{cpar}                             %
%                                                                            %
% The environment is put around each line of the output for a PlusCal        %
% algorithm.                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newenvironment{ppar}{%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}
%        \setlength{\leftmargin}{0pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{0pt}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}
%      \setlength{\itemindent}{0pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%      \item[\tstrut\hspace{\temp}]}%
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \shadebox{\usebox{\tempsbox}}\par}{}%
%  }

 %%% TESTING
 \newcommand{\xtest}[1]{\par
 \makebox[0pt][l]{\shadebox{\xtstrut\hspace*{\textwidth}}}%
 \mbox{$\mbox{}#1\mbox{}$}} 

% \newcommand{\xxtest}[1]{\par
% \makebox[0pt][l]{\shadebox{\xtstrut{#1}\hspace*{\textwidth}}}%
% \mbox{$\mbox{}#1\mbox{}$}} 

%\newlength{\pcalvspace}
%\setlength{\pcalvspace}{0pt}
% \newlength{\xxtestlen}
% \setlength{\xxtestlen}{0pt}
% \newcommand\xtstrut%
%   {\setlength{\xxtestlen}{1.15em}%
%    \addtolength{\xxtestlen}{\pcalvspace}%
%     \raisebox{\vshadelen}{\raisebox{-.25em}{\rule{0pt}{\xxtestlen}}}%
%    \global\setlength{\vshadelen}{0pt}%
%    \global\setlength{\pcalvspace}{0pt}}
   
   %%%% TESTING
   
   %% The xcpar environment
   %%  Note: overloaded use of \pcalvspace for testing.
   %%
%   \newlength{\xcparht}%
%   \newlength{\xcpardp}%
   
%   \newenvironment{xcpar}[6]{%
%  \addtocounter{pardepth}{-#1}%
%  \ifthenelse{\boolean{shading}}{\par\begin{lrbox}{\tempsbox}%
%                                 \begin{minipage}[t]{\linewidth}}{}%
%  \begin{list}{}{%
%     \edef\temp{\thegmargin}%
%     \ifthenelse{\equal{#3}{T}}%
%       {\settowidth{\leftmargin}{\hspace{\temp}\footnotesize #6\hspace{#5pt}}%
%        \addtolength{\leftmargin}{#4pt}}%
%       {\setlength{\leftmargin}{#4pt}%
%        \addtolength{\leftmargin}{#5pt}%
%        \addtolength{\leftmargin}{\temp}%
%        \setlength{\itemindent}{-#5pt}}%
%      \ifthenelse{\equal{#2}{T}}{\addtocounter{pardepth}{1}%
%                                 \setgmargin{\the\leftmargin}}{}%
%      \setlength{\labelwidth}{0pt}%
%      \setlength{\labelsep}{0pt}%
%      \setlength{\itemindent}{-\leftmargin}%
%      \setlength{\topsep}{0pt}%
%      \setlength{\parsep}{0pt}%
%      \setlength{\partopsep}{0pt}%
%      \setlength{\parskip}{0pt}%
%      \setlength{\itemsep}{0pt}%
%      \setlength{\itemindent}{#4pt}%
%      \addtolength{\itemindent}{-\leftmargin}}%
%   \ifthenelse{\equal{#3}{T}}%
%      {\item[\xtstrut\footnotesize \hspace{\temp}{#6}\hspace{#5pt}]%
%        }%
%      {\item[\xtstrut\hspace{\temp}]%
%         }%
%   \footnotesize}
% {\hspace{-\the\lastskip}\tstrut
% \end{list}%
%  \ifthenelse{\boolean{shading}}{\end{minipage}  
%                                 \end{lrbox}%
%                                 \setlength{\xcparht}{\ht\tempsbox}%
%                                 \setlength{\xcpardp}{\dp\tempsbox}%
%                                 \addtolength{\xcparht}{.15em}%
%                                 \addtolength{\xcpardp}{.2em}%
%                                 \addtolength{\xcparht}{\xcpardp}%
%                                 \hspace*{-\lcomindent}%
%                                 \makebox[0pt][l]{\raisebox{-\xcpardp}[0pt][0pt]{%
%                                      \shadebox{\rule{0pt}{\xcparht}\hspace*{\textwidth}}}}%
%                                 \hspace*{\lcomindent}\usebox{\tempsbox}%
%                                 \par}{}%
%  }
%  
% \newlength{\xmcomlen}
%\newenvironment{xmcom}[1]{%
%  \setcounter{pardepth}{0}%
%  \hspace{.65em}%
%  \begin{lrbox}{\alignbox}\sloppypar%
%      \setboolean{shading}{false}%
%      \setlength{\boxwidth}{#1pt}%
%      \addtolength{\boxwidth}{-.65em}%
%      \begin{minipage}[t]{\boxwidth}\footnotesize
%      \parskip=0pt\relax}%
%       {\end{minipage}\end{lrbox}%
%       \setlength{\xmcomlen}{\textwidth}%
%       \addtolength{\xmcomlen}{-\wd\alignbox}%
%       \settodepth{\alignwidth}{\usebox{\alignbox}}%
%       \global\setlength{\multicommentdepth}{\alignwidth}%
%       \setlength{\boxwidth}{\alignwidth}%
%       \global\addtolength{\alignwidth}{-\maxdepth}%
%       \addtolength{\boxwidth}{.1em}%
%       \raisebox{0pt}[0pt][0pt]{%
%        \ifthenelse{\boolean{shading}}%
%          {\hspace*{-\xmcomlen}\shadebox{\rule[-\boxwidth]{0pt}{0pt}%
%                                 \hspace*{\xmcomlen}\usebox{\alignbox}}}%
%          {\usebox{\alignbox}}}%
%       \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
% % a multi-line comment, whose first argument is its width in points.
%  
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE lcom ENVIRONMENT                                                       %
% ^^^^^^^^^^^^^^^^^^^^                                                       %
% A multi-line comment with no text to its left is typeset in an lcom        % 
% environment, whose argument is a number representing the indentation       % 
% of the left margin, in points.  All the text of the comment should be      % 
% inside cpar environments.                                                  % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newenvironment{lcom}[1]{%
  \setlength{\lcomindent}{#1pt} % Added for PlusCal handling.
  \par\vspace{.2em}%
  \sloppypar
  \setcounter{pardepth}{0}%
  \footnotesize
  \begin{list}{}{%
    \setlength{\leftmargin}{#1pt}
    \setlength{\labelwidth}{0pt}%
    \setlength{\labelsep}{0pt}%
    \setlength{\itemindent}{0pt}%
    \setlength{\topsep}{0pt}%
    \setlength{\parsep}{0pt}%
    \setlength{\partopsep}{0pt}%
    \setlength{\parskip}{0pt}}
    \item[]}%
  {\end{list}\vspace{.3em}\setlength{\lcomindent}{0pt}%
 }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE mcom ENVIRONMENT AND \mutivspace COMMAND                              %
% ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                              %
%                                                                           %
% A part of the spec containing a right-comment of the form                 %
%                                                                           %
%      xxxx (*************)                                                 %
%      yyyy (* ccccccccc *)                                                 %
%      ...  (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (* ccccccccc *)                                                 %
%           (*************)                                                 %
%                                                                           %
% is typeset by                                                             %
%                                                                           %
%     XXXX \begin{mcom}{d}                                                  %
%            CCCC ... CCC                                                   %
%          \end{mcom}                                                       %
%     YYYY ...                                                              %
%     \multivspace{n}                                                       %
%                                                                           %
% where the number d is the width in points of the comment, n is the        %
% number of xxxx, yyyy, ...  lines to the left of the comment.              %
% All the text of the comment should be typeset in cpar environments.       %
%                                                                           %
% This puts the comment into a single box (so no page breaks can occur      %
% within it).  The entire box is shaded iff the shading flag is true.       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\xmcomlen}%
\newenvironment{mcom}[1]{%
  \setcounter{pardepth}{0}%
  \hspace{.65em}%
  \begin{lrbox}{\alignbox}\sloppypar%
      \setboolean{shading}{false}%
      \setlength{\boxwidth}{#1pt}%
      \addtolength{\boxwidth}{-.65em}%
      \begin{minipage}[t]{\boxwidth}\footnotesize
      \parskip=0pt\relax}%
       {\end{minipage}\end{lrbox}%
       \setlength{\xmcomlen}{\textwidth}%       % For PlusCal shading
       \addtolength{\xmcomlen}{-\wd\alignbox}%  % For PlusCal shading
       \settodepth{\alignwidth}{\usebox{\alignbox}}%
       \global\setlength{\multicommentdepth}{\alignwidth}%
       \setlength{\boxwidth}{\alignwidth}%      % For PlusCal shading
       \global\addtolength{\alignwidth}{-\maxdepth}%
       \addtolength{\boxwidth}{.1em}%           % For PlusCal shading
      \raisebox{0pt}[0pt][0pt]{%
        \ifthenelse{\boolean{shading}}%
          {\ifpcalshading
             \hspace*{-\xmcomlen}%
             \shadebox{\rule[-\boxwidth]{0pt}{0pt}\hspace*{\xmcomlen}%
                          \usebox{\alignbox}}%
           \else
             \shadebox{\usebox{\alignbox}}
           \fi
          }%
          {\usebox{\alignbox}}}%
       \vspace*{\alignwidth}\pagebreak[0]\vspace{-\alignwidth}\par}
 % a multi-line comment, whose first argument is its width in points.


% \multispace{n} produces the vertical space indicated by "|"s in 
% this situation
%   
%     xxxx (*************)
%     xxxx (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (* ccccccccc *)
%      |   (*************)
%
% where n is the number of "xxxx" lines.
\newcommand{\multivspace}[1]{\addtolength{\multicommentdepth}{-#1\baselineskip}%
 \addtolength{\multicommentdepth}{1.2em}%
 \ifthenelse{\lengthtest{\multicommentdepth > 0pt}}%
    {\par\vspace{\multicommentdepth}\par}{}}

%\newenvironment{hpar}[2]{%
%  \begin{list}{}{\setlength{\leftmargin}{#1pt}%
%                 \addtolength{\leftmargin}{#2pt}%
%                 \setlength{\itemindent}{-#2pt}%
%                 \setlength{\topsep}{0pt}%
%                 \setlength{\parsep}{0pt}%
%                 \setlength{\partopsep}{0pt}%
%                 \setlength{\parskip}{0pt}%
%                 \addtolength{\labelsep}{0pt}}%
%  \item[]\footnotesize}{\end{list}}
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    % Typesets a sequence of paragraphs like this:                         %
%    %                                                                      %
%    %      left |<-- d1 --> XXXXXXXXXXXXXXXXXXXXXXXX                       %
%    %    margin |           <- d2 -> XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                                                          %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %           |                    XXXXXXXXXXXXXXX                       %
%    %                                                                      %
%    % where d1 = #1pt and d2 = #2pt, but with no vspace between            %
%    % paragraphs.                                                          %
%    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Commands for repeated characters that produce dashes.              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raisedDash{wd}{ht}{thk} makes a horizontal line wd characters wide, 
% raised a distance ht ex's above the baseline, with a thickness of 
% thk em's.
\newcommand{\raisedDash}[3]{\raisebox{#2ex}{\setlength{\alignwidth}{.5em}%
  \rule{#1\alignwidth}{#3em}}}

% The following commands take a single argument n and produce the
% output for n repeated characters, as follows
%   \cdash:    -
%   \tdash:    ~
%   \ceqdash:  =
%   \usdash:   _
\newcommand{\cdash}[1]{\raisedDash{#1}{.5}{.04}}
\newcommand{\usdash}[1]{\raisedDash{#1}{0}{.04}}
\newcommand{\ceqdash}[1]{\raisedDash{#1}{.5}{.08}}
\newcommand{\tdash}[1]{\raisedDash{#1}{1}{.08}}

\newlength{\spacewidth}
\setlength{\spacewidth}{.2em}
\newcommand{\e}[1]{\hspace{#1\spacewidth}}
%% \e{i} produces space corresponding to i input spaces.


%% Alignment-file Commands

\newlength{\alignboxwidth}
\newlength{\alignwidth}
\newsavebox{\alignbox}

% \al{i}{j}{txt} is used in the alignment file to put "%{i}{j}{wd}"
% in the log file, where wd is the width of the line up to that point,
% and txt is the following text.
\newcommand{\al}[3]{%
  \typeout{\%{#1}{#2}{\the\alignwidth}}%
  \cl{#3}}

%% \cl{txt} continues a specification line in the alignment file
%% with text txt.
\newcommand{\cl}[1]{%
  \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
  \settowidth{\alignboxwidth}{\usebox{\alignbox}}%
  \addtolength{\alignwidth}{\alignboxwidth}%
  \usebox{\alignbox}}

% \fl{txt} in the alignment file begins a specification line that
% starts with the text txt.
\newcommand{\fl}[1]{%
  \par
  \savebox{\alignbox}{\mbox{$\mbox{}#1\mbox{}$}}%
  \settowidth{\alignwidth}{\usebox{\alignbox}}%
  \usebox{\alignbox}}



  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ordinarily, TeX typesets letters in math mode in a special math italic    %
% font.  This makes it typeset "it" to look like the product of the         %
% variables i and t, rather than like the word "it".  The following         %
% commands tell TeX to use an ordinary italic font instead.                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ifx\documentclass\undefined
\else
  \DeclareSymbolFont{tlaitalics}{\encodingdefault}{cmr}{m}{it}
  \let\itfam\symtlaitalics
\fi

\makeatletter
\newcommand{\tlx@c}{\c@tlx@ctr\advance\c@tlx@ctr\@ne}
\newcounter{tlx@ctr}
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7061\relax
\mathcode`a=\tlx@c \mathcode`b=\tlx@c \mathcode`c=\tlx@c \mathcode`d=\tlx@c
\mathcode`e=\tlx@c \mathcode`f=\tlx@c \mathcode`g=\tlx@c \mathcode`h=\tlx@c
\mathcode`i=\tlx@c \mathcode`j=\tlx@c \mathcode`k=\tlx@c \mathcode`l=\tlx@c
\mathcode`m=\tlx@c \mathcode`n=\tlx@c \mathcode`o=\tlx@c \mathcode`p=\tlx@c
\mathcode`q=\tlx@c \mathcode`r=\tlx@c \mathcode`s=\tlx@c \mathcode`t=\tlx@c
\mathcode`u=\tlx@c \mathcode`v=\tlx@c \mathcode`w=\tlx@c \mathcode`x=\tlx@c
\mathcode`y=\tlx@c \mathcode`z=\tlx@c
\c@tlx@ctr=\itfam \multiply\c@tlx@ctr"100\relax \advance\c@tlx@ctr "7041\relax
\mathcode`A=\tlx@c \mathcode`B=\tlx@c \mathcode`C=\tlx@c \mathcode`D=\tlx@c
\mathcode`E=\tlx@c \mathcode`F=\tlx@c \mathcode`G=\tlx@c \mathcode`H=\tlx@c
\mathcode`I=\tlx@c \mathcode`J=\tlx@c \mathcode`K=\tlx@c \mathcode`L=\tlx@c
\mathcode`M=\tlx@c \mathcode`N=\tlx@c \mathcode`O=\tlx@c \mathcode`P=\tlx@c
\mathcode`Q=\tlx@c \mathcode`R=\tlx@c \mathcode`S=\tlx@c \mathcode`T=\tlx@c
\mathcode`U=\tlx@c \mathcode`V=\tlx@c \mathcode`W=\tlx@c \mathcode`X=\tlx@c
\mathcode`Y=\tlx@c \mathcode`Z=\tlx@c
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                THE describe ENVIRONMENT                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% It is like the description environment except it takes an argument
% ARG that should be the text of the widest label.  It adjusts the
% indentation so each item with label LABEL produces
%%      LABEL             blah blah blah
%%      <- width of ARG ->blah blah blah
%%                        blah blah blah
\newenvironment{describe}[1]%
   {\begin{list}{}{\settowidth{\labelwidth}{#1}%
            \setlength{\labelsep}{.5em}%
            \setlength{\leftmargin}{\labelwidth}% 
            \addtolength{\leftmargin}{\labelsep}%
            \addtolength{\leftmargin}{\parindent}%
            \def\makelabel##1{\rm ##1\hfill}}%
            \setlength{\topsep}{0pt}}%% 
                % Sets \topsep to 0 to reduce vertical space above
                % and below embedded displayed equations
   {\end{list}}

%   For tlatex.TeX
\usepackage{verbatim}
\makeatletter
\def\tla{\let\%\relax%
         \@bsphack
         \typeout{\%{\the\linewidth}}%
             \let\do\@makeother\dospecials\catcode`\^^M\active
             \let\verbatim@startline\relax
             \let\verbatim@addtoline\@gobble
             \let\verbatim@processline\relax
             \let\verbatim@finish\relax
             \verbatim@}
\let\endtla=\@esphack

\let\pcal=\tla
\let\endpcal=\endtla
\let\ppcal=\tla
\let\endppcal=\endtla

% The tlatex environment is used by TLATeX.TeX to typeset TLA+.
% TLATeX.TLA starts its files by writing a \tlatex command.  This
% command/environment sets \parindent to 0 and defines \% to its
% standard definition because the writing of the log files is messed up
% if \% is defined to be something else.  It also executes
% \@computerule to determine the dimensions for the TLA horizonatl
% bars.
\newenvironment{tlatex}{\@computerule%
                        \setlength{\parindent}{0pt}%
                       \makeatletter\chardef\%=`\%}{}


% The notla environment produces no output.  You can turn a 
% tla environment to a notla environment to prevent tlatex.TeX from
% re-formatting the environment.

\def\notla{\let\%\relax%
         \@bsphack
             \let\do\@makeother\dospecials\catcode`\^^M\active
             \let\verbatim@startline\relax
             \let\verbatim@addtoline\@gobble
             \let\verbatim@processline\relax
             \let\verbatim@finish\relax
             \verbatim@}
\let\endnotla=\@esphack

\let\nopcal=\notla
\let\endnopcal=\endnotla
\let\noppcal=\notla
\let\endnoppcal=\endnotla

%%%%%%%%%%%%%%%%%%%%%%%% end of tlatex.sty file %%%%%%%%%%%%%%%%%%%%%%% 
% last modified on Fri  3 August 2012 at 14:23:49 PST by lamport
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\begin_local_layout
InsetLayout Flex:Code
    LyxType               charstyle
    LabelString           code
    LatexType             command
    LatexName             code
    Font
      Family              Typewriter
    EndFont
    Preamble
    \newcommand{\code}[1]{\texttt{#1}}
    EndPreamble
    InToc                 true
    HTMLTag               code
End
\end_local_layout
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "Konzeption und Implementierung eines Übersetzungsschemas zur automatischen Verifikation von ReActor-Spezifikationen"
\pdf_author "Daniel Sturm"
\pdf_subject "Supporting Actor Modelcheking"
\pdf_keywords "Actors, ReActor, TLA+, TLC, Modelchecking"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 1
\paragraph_separation skip
\defskip bigskip
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle plain
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Title
Konzeption und Implementierung eines Übersetzungsschemas zur automatischen
 Verifikation von ReActor-Spezifikationen
\end_layout

\begin_layout Subtitle
Version 0.4_alpha
\end_layout

\begin_layout Author
Daniel Sturm, Informatik (Diplom), 221586
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset FloatList table

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Problemstellung und Motivation
\end_layout

\begin_layout Standard
Gemäß dem Mooreschen Gesetz verdoppelt sich alle 1-2 Jahre die Leistungsfähigkei
t der Prozessoren\SpecialChar \@.
 Lange geschah dies in Form einer Erhöhung der CPU-Taktfrequenz\SpecialChar \@.

 In letzter Zeit geht der Trend in eine andere Richtung\SpecialChar \@.
 Die Leistungsfähigkeit
 erhöht sich durch die Parallelisierung von Prozessen
\begin_inset CommandInset citation
LatexCommand cite
key "sutter2005"

\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
Diese Trendwende hat zur Folge, dass sich die Art und Weise wie Programme
 entwickelt werden darauf anpassen muss\SpecialChar \@.
 Programme können nicht mehr nur
 aus strikt nacheinander auszuführenden Anweisungen bestehen\SpecialChar \@.
 Statt dessen
 müssen Teile des Programmcodes parallel zueinander ausgeführt werden können\SpecialChar \@.

\end_layout

\begin_layout Standard
Bei einer parallelen Ausführung von Programmen ist die Reihenfolge der ausgeführ
ten Anweisungen nicht immer vorhersehbar\SpecialChar \@.
 Dadurch entstehen neue Probleme
 und Herausforderungen\SpecialChar \@.
 Unter anderem muss der Zugriff auf gemeinsame Ressourcen
 wie beispielsweise Bereiche im Arbeitsspeicher koordiniert werden, damit
 sich Prozesse nicht gegenseitig blockieren (Deadlock
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Ein Deadlock  tritt dann auf, wenn sich das System in einem Zustand befindet,
 von dem es keine mögliche Kette von Zustandsüberführungen gibt, die das
 System in einen Endzustand bringen können
\begin_inset CommandInset citation
LatexCommand cite
key "coffman1971"

\end_inset

\SpecialChar \@.
 Dies geschieht zum Beispiel, wenn auf Ereignisse gewartet wird, die letztendlic
h durch genau diese Ereignisse hervorgerufen werden\SpecialChar \@.

\end_layout

\end_inset

) oder durch ungeschicktes Timing Speicherinhalte verfälscht werden (Race
 Condition
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Eine Race Condition  entsteht, wenn in einem System durch eine bestimmte
 Reihenfolge von Zustandsüberführungen ein unerwünschter Systemzustand erreicht
 wird
\begin_inset CommandInset citation
LatexCommand cite
key "unger1970"

\end_inset

\SpecialChar \@.
 Das passiert zum Beispiel, wenn ein System sich in einem inkonsistenten
 Zustand befindet und daraufhin agiert anstatt die Inkonsistenz aufzulösen\SpecialChar \@.

\end_layout

\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
Probleme, die durch die gemeinsame Nutzung von Speicherbereichen oder der
 zeit\SpecialChar \-
lich\SpecialChar \-
en Ausführung von Operationen entstehen, können entweder durch
 schwer überschaubare Synchronisationsmechanismen vermieden werden, oder
 durch die Einhaltung einfacher Grundprinzipien umgangen werden.
\end_layout

\begin_layout Standard
Ein Rechenmodell zur Modellierung paralleler Prozesse ist das Aktormodell
\begin_inset CommandInset citation
LatexCommand citep
key "agha1985"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "agha1990a"

\end_inset

\SpecialChar \@.
 Das Aktormodell nutzt zur Prozesskommunikation keinen gemeinsamen Speicherberei
ch (shared memory) sondern Nachrichten (message passing)\SpecialChar \@.
 Ein Aktor kann
 im Nachrichten verarbeiten und senden sowie neue Aktoren erzeugen\SpecialChar \@.
 Eine
 detailiertere Einführung in die Grundprinzipien des Aktormodells befindet
 sich in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Einführung-Aktormodell"

\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
Um ein Aktor-Systemen bereits in der Entwurfsphase zu prüfen, ist es notwendig
 ein Aktor-System auf abstraktem Niveau formal zu spezifizieren\SpecialChar \@.
 Eine Möglichkeit
 Aktorsysteme deklarativ
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Deklarative Sprachen beschreiben keine konkreten Arbeitsschritte und Abläufe,
 wie das bei imperativen Sprachen der Fall ist\SpecialChar \@.
 Sie bestehen hingegen aus
 logischen Ausdrücken und Funktionen bzw.
 Operationen\SpecialChar \@.
 Hierbei kann z.B.
 durch die Verwendung des Existenzquantors(
\begin_inset Formula $\E$
\end_inset

) eine Formel nur so eindeutig wie nötig formuliert werden ohne dabei zu
 konkret zu werden\SpecialChar \@.

\end_layout

\end_inset

 zu spezifizieren ist ReActor
\begin_inset CommandInset citation
LatexCommand cite
key "burmeister2013a"

\end_inset

\SpecialChar \@.
 Weitere Details zu ReActor in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:ReActor"

\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
Komplexe Systemen habem meist eine hohe Zahl an möglichen Zuständen und
 Abläufen\SpecialChar \@.
 Dabei reicht es meist nicht einzelne Situationen zu testen oder
 einige Abläufe zu simulieren um die Funktionsfähigkeit fest zu stellen\SpecialChar \@.

 Besonders bei sicherheitskritischen Systemen ist es wichtig das System
 vollständig zu analysieren\SpecialChar \@.
 Ein formal spezifiziertes System kann durch
 ein automatisches Verfahren, genannt Model-Checking, verifiziert werden
\begin_inset CommandInset citation
LatexCommand cite
key "clarke1999"

\end_inset

\SpecialChar \@.
 Mehr zum Thema Modellprüfer (engl.
 Model Checker) wird im 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Einführung-Modellprüfung"

\end_inset

 behandelt\SpecialChar \@.

\end_layout

\begin_layout Standard
Ein Aktorsystem kann mithilfe eines Modellprüfers verifiziert werden\SpecialChar \@.
 Dazu
 muss ein allgemeines Ausführungsmodell für das zu prüfende Aktorsystem
 erstellt werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Um die Modellierung des Aktorsystems zu erleichtern, soll eine reine Spezifikati
on von Aktoren in ReActor in ein vollständiges Ausführungsmodell in TLA+
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 übertragen werden (engl.
 code
\begin_inset space ~
\end_inset

transformation)\SpecialChar \@.
 In diesem vollständigen Ausführungsmodell wird die Spezifikation
 der Aktoren in die be\SpecialChar \-
reits vorhandene Spezifikation des allgemeinen Verhaltens
 der Aktoren eingebettet\SpecialChar \@.

\end_layout

\begin_layout Chapter
Grundlagen
\begin_inset CommandInset label
LatexCommand label
name "chap:Grundlagen"

\end_inset


\end_layout

\begin_layout Standard
Die Ergebnisse dieser Arbeit sollen als Unterstützung beim automatischen
 Verifizieren von Aktor-Modellen dienen\SpecialChar \@.
 Die automatische Verifikation wird
 in diesem Fall durch den TLC-Modellprüfer übernommen\SpecialChar \@.
 Der TLC-Modellprüfer
 validiert TLA+-Modelle, TLC unterstützt dabei lediglich einen Teil von
 TLA+\SpecialChar \@.

\end_layout

\begin_layout Standard
Um ein Aktorsystem durch den TLC-Modellprüfer zu verifizieren, muss zunächt
 in TLA+ das allgemeine Verhalten eines Aktorsystems modelliert werden\SpecialChar \@.
 Dazu
 gehören Mechanismen wie der Lebenszyklus und die Kommunikation der Aktoren
 im Allgemeinen\SpecialChar \@.
 Auf dieser Grundlage können dann die einzelnen Aktoren mit
 ihren Eigenschaften und ihrem Verhalten deklariert werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Wie in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Aktor-Modell-Checking-ohne-Unterstützung"

\end_inset

 dargestellt, besteht das allgemeine Ausführungsmodell aus zwei Teilen,
 aus dem individuellen Verhalten der einzelnen Aktoren und allem was den
 Lebenszyklus und die Kommunikation der Aktoren beschreibt\SpecialChar \@.
 Beides zusammen
 wird vom TLC-Modellprüfer ausgewertet\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Aktormodell Checking ohne Unterstützung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Aktor-Modell-Checking-ohne-Unterstützung"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=5cm,
\end_layout

\begin_layout Plain Layout

 box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (TA) {Aktor in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, dashed] (AM) [below=0.6cm of TA] {Ausführungsmodell 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (TLC) [below=0.6cm of AM] {TLC 
\backslash

\backslash
 Modellprüfer};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (R) [below=0.6cm of TLC] {Ergebnis};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (TE) [left of=AM] {Allgemeines Verhalten 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (S)[above=0.6 of TE] {Spezifizieren};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[rectangle,draw,gray,fit={($(AM.north west)+(-0.2cm,0.2cm)$)
\end_layout

\begin_layout Plain Layout

                                 ($(AM.south east)+(0,-0.1cm)$)
\end_layout

\begin_layout Plain Layout

                                 ($(TLC.south west)+(0,-0.1cm)$)
\end_layout

\begin_layout Plain Layout

                                }] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (S) to node {} (TA);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (S) to node {} (TE);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TA) to node {} (AM);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TE) to node {} (AM);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (AM) to node {} (TLC);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TLC) to node {} (R);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ist das allgemeine Verhalten des Aktormodells erst mal beschrieben bleibt
 dies für jedes Aktormodell das selbe\SpecialChar \@.
 Lediglich die Beschreibung der Aktoren
 muss entsprechend angepasst werden, wenn ein anderes Verhalten gewünscht
 ist\SpecialChar \@.

\end_layout

\begin_layout Standard
Wenn die Aktoren direkt in TLA+ beschrieben werden, muss an vielen Stellen
 boilerplate Code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Boilerplate Code ist der Teil des Codes, der meist in unveränderter Form
 an mehreren Stellen benötigt wird\SpecialChar \@.

\end_layout

\end_inset

 verwendet werden\SpecialChar \@.
 Dieser unnötige Spe\SpecialChar \-
zi\SpecialChar \-
fi\SpecialChar \-
ka\SpecialChar \-
tions\SpecialChar \-
auf\SpecialChar \-
wand und damit potentielle
 Fehlerquelle kann vermieden werden, indem aus der reinen Beschreibung eines
 Aktors in ReActor die zugehörige Spezifikation in TLA+ generiert wird,
 wie in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unterstütztes-Aktor-Modell-Checking"

\end_inset

 gezeigt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Aktormodell Checking mit Unterstützung 
\begin_inset CommandInset label
LatexCommand label
name "fig:Unterstütztes-Aktor-Modell-Checking"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=5cm,
\end_layout

\begin_layout Plain Layout

 box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (RA) {Aktorspezifikation 
\backslash

\backslash
 in ReActor};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (CT) [below=0.6cm of RA] {Code Transformator};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (TA) [below=0.6cm of CT] {Aktor in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, dashed] (AM) [below=0.6cm of TA] {Ausfühungsmodell 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (TLC) [below=0.6cm of AM] {TLC 
\backslash

\backslash
 Modellprüfer};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (R) [below=0.6cm of TLC] {Ergebnis};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (TE) [left of=AM] {Allgemeines Verhalten 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (S) [left of=RA] {Spezifizieren};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[rectangle,draw,gray,fit={($(TE.north west)+(-0.1cm,0)$)
\end_layout

\begin_layout Plain Layout

                                 ($(TLC.south west)+(0,-0.1cm)$)
\end_layout

\begin_layout Plain Layout

                                 ($(CT.north east)+(0.1cm,0.2cm)$)
\end_layout

\begin_layout Plain Layout

                                }] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (S) to node {} (RA);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (RA) to node {} (CT);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (CT) to node {} (TA);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TA) to node {} (AM);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TE) to node {} (AM);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (AM) to node {} (TLC);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (TLC) to node {} (R);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ein Aktormodell wird bei der Variante aus 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unterstütztes-Aktor-Modell-Checking"

\end_inset

 nur aus der Beschreibung des Verhalten der Aktoren in Form von ReActor
 spezifiziert\SpecialChar \@.
 Diese ReActor Spezifikation wird mittels Code Transformation
 in eine entsprechende TLA+ Spezifikation transformiert\SpecialChar \@.
 Diese Spezifikation
 ergibt dann im Zusammenspiel mit der Spezifikation des Allgemeinen Verhaltens
 das Ausführungsmodell, welches dann durch den TLC-Modellprüfer verifiziert
 wird\SpecialChar \@.

\end_layout

\begin_layout Standard
Eine genaue Beschreibung von ReActor befindet sich in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:ReActor"

\end_inset

\SpecialChar \@.
 Weitere Details zum Ausführungsmodell finden sich in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Allgemeines-Ausführungsmodell"

\end_inset

\SpecialChar \@.
 
\end_layout

\begin_layout Section
Aktormodell
\begin_inset CommandInset label
LatexCommand label
name "sec:Einführung-Aktormodell"

\end_inset


\end_layout

\begin_layout Standard
Die Grundlage des Aktormodells ist der Aktor\SpecialChar \@.
 Der Aktor, als kleinste Einheit
 des Rechenmodells existiert, um drei wesentliche Aufgaben zu erfüllen:
 Informationen zu verarbeiten, Informationen zu speichern und mit anderen
 Aktoren zu kommunizieren.
\end_layout

\begin_layout Standard
Ein Aktor hat folgende Möglichkeiten eine eingehende Nachrichten zu verarbeiten:
\end_layout

\begin_layout Description
Nachrichten
\begin_inset space ~
\end_inset

senden Der Aktor sendet eine endliche Menge von Nachrichten an ihm bekannte
 Aktoren\SpecialChar \@.

\end_layout

\begin_layout Description
Verhalten
\begin_inset space ~
\end_inset

anpassen Der Aktor legt fest, wie auf die nächste Nachricht reagiert werden
 soll\SpecialChar \@.
 Dies geschieht entweder durch Änderung seines Zustandes oder das Verwandel
n in einen anderen Aktortyp\SpecialChar \@.

\end_layout

\begin_layout Description
Aktoren
\begin_inset space ~
\end_inset

erzeugen Der Aktor erzeugt eine endliche Menge von neuen Aktoren\SpecialChar \@.

\end_layout

\begin_layout Standard
Aktoren können Nachrichten unabhängig von einanderverarbeiten\SpecialChar \@.
 Das Konzept
 eines Aktors baut auf zwei getrennten Vorgängen: Nachrichten entgegen nehmen
 und Nachrichten verarbeiten\SpecialChar \@.
 Jeder Aktor kann zu jeder Zeit Nachrichten
 empfangen und verarbeitet unabhängig davon diese Nachrich\SpecialChar \-
ten.
 Die Verarbeitung geschieht sequenziell und ist dabei zeitlich sowie räumlich
 vollständig separat von anderen Aktoren\SpecialChar \@.

\end_layout

\begin_layout Subsection
Besonderheiten von ReActor
\end_layout

\begin_layout Standard
Die in dieser Arbeit verwendete Notation zur Beschreibung von Aktoren, ReActor
\begin_inset CommandInset citation
LatexCommand cite
key "burmeister2013a"

\end_inset

 hat einige Erweiterungen gegenüber der allgemeinen Aktorsysteme\SpecialChar \@.

\end_layout

\begin_layout Standard
Eine Besonderheit von ReActor ist, dass zusätzlich zur expliziten Verarbeitung
 einer Nachricht (Operation) auch die Möglichkeit zur Beschreibung einer
 internen Zustandsveränderung (Ereignis) besteht\SpecialChar \@.
 Diese Eigenschaft ist dafür
 wichtig um Ereignisse der Umgebung des Aktorsystems simulieren zu können\SpecialChar \@.

\end_layout

\begin_layout Standard
Um eine theoretisch unendliche Menge von Aktoren auf einem praktisch endlichen
 System zu Simulieren hat jeder Aktor eine Menge von ihm bekannten Aktoren
 (acquantances)\SpecialChar \@.
 In dieser Menge wird festgehalten welche Anderen Aktoren
 vom Aktor noch benötigt werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Aktoren, die bei keinem Aktor mehr bekannt sind und keine Operation oder
 Ereignisse auszuwerten haben können von der Simulation wiederverwertet
 werden\SpecialChar \@.

\end_layout

\begin_layout Subsection
Beispiel eines Aktorsystems
\end_layout

\begin_layout Standard
Die Oben genannten Eigenschaften, werden nun anhand eines kurzen abstrakten
 Beispiels erläutert\SpecialChar \@.
 In diesem Beispiel erhält der Aktor [A] eine Nachrit,
 erzeugt drei weitere Aktoren und sendet Nachrichten an die eben erzeugten
 Aktoren\SpecialChar \@.
 Von diesen Aktoren schicken zwei eine Nachricht zurück und der
 Aktor sendet sein Ergebnis an einen weiteren Aktor\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Beispielschritte eines Aktorsystems 
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Aktorsystem"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=0.6cm,
\end_layout

\begin_layout Plain Layout

  box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (A1) {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, gray, fill=white] (S) [left=of A1] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (1) [left=1.6cm of A1.north] {1.};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (A2) [right=3.5cm of A1] {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (2) [left=1.5cm of A2.north] {2.};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Y2) [below=0.8cm of A2] {Y};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (X2) [left=of Y2] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Z2) [right=of Y2] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (A3) [right=3.5cm of A2] {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (3) [left=1.6cm of A3.north] {3.};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Y3) [below=0.8cm of A3] {Y};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (X3) [left=of Y3] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Z3) [right=of Y3] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (A4) [below=2.5cm of A1] {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (4) [left=1.6cm of A4.north] {4.};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Y4) [below=0.8cm of A4] {Y};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (X4) [left=of Y4] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (Z4) [right=of Y4] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (A5) [right=3.5cm of A4] {A};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, gray, fill=white] (D) [right=of A5] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (5) [left=1.6cm of A5.north] {5.};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, dashed] (Y5) [below=0.8cm of A5] {Y};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, dashed] (X5) [left=of Y5] {X};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, dashed] (Z5) [right=of Y5] {Z};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AL) [right=2.5cm of A5] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (AD) [right=0.6cm of AL] {Aktor};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (C1) [below left=0.2cm of AL] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (C2) [below right=0.2cm of AL] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (CD) [right=-0.2cm of C2] {Erzeugen};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (M1) [below left=0.8cm and 0.2cm of AL] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (M2) [below right=0.8cm and 0.2cm of AL] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (MD) [right=-0.2cm of M2] {Nachricht};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[rectangle,draw,lightgray,fit={(AD)
\end_layout

\begin_layout Plain Layout

                                   ($(M1.south west)+(+0.6cm,-0.2cm)$)
\end_layout

\begin_layout Plain Layout

                                   ($(AD.north west)+(+0.4cm,0)$)
\end_layout

\begin_layout Plain Layout

                                   ($(MD.south west)+(+2.0,0)$)
\end_layout

\begin_layout Plain Layout

                                  }] {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  %creations
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{scope}[dashed,->]
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A2) to node {} (X2);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A2) to node {} (Y2);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A2) to node {} (Z2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (C1) to node {} (C2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  %messages
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{scope}[->]
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (S) to node {} (A1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A3) to node {} (X3);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A3) to node {} (Y3);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A3) to node {} (Z3);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (Y4) to node {} (A4);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (Z4) to node {} (A4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A5) to node {} (D);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (M1) to node {} (M2);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es folgt eine detailiertere Beschreibung der Schritte der 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-Aktorsystem"

\end_inset

 
\end_layout

\begin_layout Enumerate
Der Aktor [A] bekommt von einem nicht näher spezifizierten Aktor eine Nachricht\SpecialChar \@.

 Aktor [A] wird nun Aktiv und unternimmt eine reihe von Aktrionen um beispielswe
ise eine Berechnung durchzuführen\SpecialChar \@.

\end_layout

\begin_layout Enumerate
Zunächst erzeugt Aktor [A] drei weitere Aktoren [X], [Y] und [Z]\SpecialChar \@.

\end_layout

\begin_layout Enumerate
An alle Neu erzeugten Aktoren werden nun Nachrichten gesendet, die weitere
 instruktionen enthalten, was diese tun sollen\SpecialChar \@.

\end_layout

\begin_layout Enumerate
Irgendwann melden sich die Aktoren [Y] und [Z] durch das Senden einer Nachricht
 mit einem Ergebnis zurück bei Aktor [A]\SpecialChar \@.
 Aktor [X] hat aus nicht weiter
 wichtigen Gründen noch kein Ergebnis ermitteln können\SpecialChar \@.

\end_layout

\begin_layout Enumerate
Aktor [A] benötigt die Aktoren [X], [Y] und [Z] nicht mehr\SpecialChar \@.
 Der Aktor [A]
 sendet ein Ergebnis, weiter an einen nicht näher spezifizierten anderen
 Aktor\SpecialChar \@.

\end_layout

\begin_layout Section
Modellprüfung
\begin_inset CommandInset label
LatexCommand label
name "sec:Einführung-Modellprüfung"

\end_inset


\end_layout

\begin_layout Standard
Die Aufgabe eines Modellprüfers ist es zu validieren, ob eine abstrakte
 Systembeschreibung (Modell) die an sie gestellten Anforderungen bzw.
 gewünschte Eigenschaften erfüllt\SpecialChar \@.
 Zum automatischen Prüfen muss das Modell
 formal beschrieben sein und eine formale Spezifikationm der Anforderungen
 an das zu prüfende Modell vorliegen\SpecialChar \@.
 Das Modell beschreibt alle möglichen
 Zustände des Systems, setzt die Startzustände fest und legt übergänge zwischen
 Zuständen fest\SpecialChar \@.
 Die Spezifikation der Systemeigenschaften trifft Aussagen
 über einzelne Zustände\SpecialChar \@.
 Ein Modellprüfer verifiziert ob die Startzustände
 und alle Zustandsübergänge des Modells die Bedingungen der spezifizierten
 Eigenschaften erfüllen\SpecialChar \@.

\begin_inset CommandInset citation
LatexCommand citep
key "clarke1999"

\end_inset


\end_layout

\begin_layout Standard
Ein Modellprüfer konstruiert vom Initialzustand ausgehend durch Anwendung
 der Regeln einen nicht-deterministischen Automaten oder eine Art Kripke-Struktu
r
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Eine Kripke-Struktur ist ein gerichteter Graph\SpecialChar \@.
 Die Knoten entsprechen Zuständen
 und die Kanten stehen für Zustandsüberführungen\SpecialChar \@.
 Eine nichtleere Teilmenge
 der Zustände sind als Startzustände gekennzeichnet\SpecialChar \@.

\end_layout

\end_inset

 aller möglichen Zustände (Zustandsraum)\SpecialChar \@.
 Da dieser Zustands\SpecialChar \-
raum unter gewissen
 Voraussetzungen unendlich groß werden kann, sollte dessen Exploration in
 diesem Fall Grenzen unterliegen.
 Dies kann zum einen dadurch geschehen, dass der Wertebereich der einzelnen
 Zustandsvariablen ein\SpecialChar \-
ge\SpecialChar \-
schränkt wird oder die maximale Anzahl der anzuwendenden
 Regelschritte begrenzt wird.
\end_layout

\begin_layout Subsection
TLA+ und TLC
\end_layout

\begin_layout Standard
Mit der von Leslie Lamport entwickelten Sprache 
\begin_inset Quotes pld
\end_inset

Temporal Logic of Actions
\begin_inset Quotes prd
\end_inset

 (TLA)
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 ist es möglich Systeme mit Hilfe einer logischen Formel zu beschreiben\SpecialChar \@.

\end_layout

\begin_layout Standard
Eine Spezifikation (
\begin_inset Formula $Spec$
\end_inset

) besteht dabei aus Variablen (
\begin_inset Formula $var_{1},\text{…},var_{n}$
\end_inset

), deren Werte den aktuellen Zustand eines Systems repräsentieren und einer
 temporallogischen Formel 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Spec"

\end_inset

, die Aussagen über den Inhalt dieser Variablen zu bestimmten Zeiten macht\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Spec\defeq Init\land\Box[Next]_{<var_{1},\text{…},var_{n}>}\label{eq:Spec}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Aus dieser Formel 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Spec"

\end_inset

 lassen sich durch den Teilausdruck 
\begin_inset Formula $Init$
\end_inset

 mögliche Startzustände sowie aus 
\begin_inset Formula $Next$
\end_inset

 zulässige Zustandsüberführungen herleiten\SpecialChar \@.
 Dadurch lässt sich ausgehend
 von den Startzuständen und durch alle möglichen Zustandsüberführungen der
 Zustandsraum explorieren und eine Art Kripke-Struktur bilden\SpecialChar \@.
 Diese Struktur
 kann als Modell des Systems angesehen werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Die geforderten Eigenschaften des Systems werden in TLA durch Eigenschaften
 bzw.
 Invarianten formalisiert 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Property"

\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Property\defeq\Box Invariant\label{eq:Property}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Der TLC-Modellprüfer ermittelt auf die oben genannte Weise 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Spec"

\end_inset

 alle möglichen Systemzustände und prüft bei jedem Zustand, ob die angegebene
 Invariante 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Property"

\end_inset

 korrekt ist\SpecialChar \@.
 Der Modelprüfter verifiziert ob alle Zustände die in der Spezifikat
ion des Models gültig sind auch in der Spezifikation der Eigenschaften gültig
 sind 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Prove"

\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
Spec\Rightarrow Property\label{eq:Prove}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
TLC ist nicht in der Lage alle Ausdrücke von TLA+ zu verarbeiten, daher
 darf sich das Ausführungsmodell und auch das Resultat der Übertragung nur
 auf den Anteil von TLA+ beschränken, der von TLC unterstützt wird\SpecialChar \@.

\end_layout

\begin_layout Standard
TLC unterstützt beispielsweise nicht die Auswertung von Existenzquantoren
 in temporallogischen Formeln (
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 Abschnitt 14.6 Seite 262)\SpecialChar \@.
 Oder Aktions-Kompositions-Operator, der die kombiniert
e Ausführung von Aktionen in einem Atomaren Schritt ermöglicht (
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 Abschnitt 7.3 Seite 77)\SpecialChar \@.

\end_layout

\begin_layout Standard
Weitere Einschränkungen sind dem Buch 
\begin_inset Quotes pld
\end_inset

Spe\SpecialChar \-
ci\SpecialChar \-
fy\SpecialChar \-
ing Sys\SpecialChar \-
tems
\begin_inset Quotes prd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 zu entnehmen\SpecialChar \@.

\end_layout

\begin_layout Subsection
Beispiel einer Modelbeschreibung in TLA+
\end_layout

\begin_layout Standard
In folgendem Beispiel wird ein Modell in TLA+ beschrieben\SpecialChar \@.
 Der Zustand wird
 durch die Variablen 
\begin_inset Formula $a$
\end_inset

 und 
\begin_inset Formula $b$
\end_inset

 repräsentiert\SpecialChar \@.
 Beide Variablen können mit Wahrheitswerten wahr oder falsch
 belegt sein, dadurch ergeben sich 4 mögliche Zustände\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{-2em}
\end_layout

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Modell des Beispiels 
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-Modell"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=1cm,
\end_layout

\begin_layout Plain Layout

  box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  {
\backslash
itshape
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (A) {$a 
\backslash
land b$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (B) [right=of A] {$
\backslash
neg a 
\backslash
land b$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (C) [below=of A] {$a 
\backslash
land 
\backslash
neg b$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (D) [below=of B] {$
\backslash
neg a 
\backslash
land 
\backslash
neg b$};
\end_layout

\begin_layout Plain Layout

  
\backslash
node  (S) [right=of B] {};
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
begin{scope}[->,rounded corners=2mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (B) to node {} (A);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (S) to node {
\backslash
tiny Start} (B);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[bend right=30] (A) to node {} (C);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[bend right=30] (C) to node {} (A);
\end_layout

\begin_layout Plain Layout

  
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset

Das Modell lässt sich als gerichteter Graph wie in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-Modell"

\end_inset

 gezeigt darstellen\SpecialChar \@.
 Ein Knoten entspricht hierbei einem Möglichen Systemzustand
 und eine Kante entspricht einem Schritt bzw.
 Zustandsübergang\SpecialChar \@.
 Der Zustand in dem 
\begin_inset Formula $\neg a\land\neg b$
\end_inset

 gillt wird nie erreicht\SpecialChar \@.

\end_layout

\begin_layout Standard
Dieses Modell kann in TLA+ beschrieben werden, wie in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-Modell"

\end_inset

 gezeigt wird\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 20
placement L
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TLA+ des Beispiels 
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-TLA"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/Example.inc"

\end_inset


\end_layout

\end_inset

Im Initialzustand soll 
\begin_inset Formula $a$
\end_inset

 falsch und 
\begin_inset Formula $b$
\end_inset

 wahr sein, dadurch erfüllt nur ein Zustand die Formel (
\begin_inset Formula $Init$
\end_inset

) des Initialzustandes\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Formel für die Folgezustände (
\begin_inset Formula $Next$
\end_inset

) ist kann durch die Disjunktion durch zwei Möglichkeiten erfüllt werden\SpecialChar \@.

 Entweder ist 
\begin_inset Formula $a$
\end_inset

 falsch, der Wert von 
\begin_inset Formula $a$
\end_inset

 soll im nächsten Zustand invertiert sein und 
\begin_inset Formula $b$
\end_inset

 bleibt unverändert\SpecialChar \@.
 Oder 
\begin_inset Formula $a$
\end_inset

 ist wahr, der Wert von 
\begin_inset Formula $b$
\end_inset

 soll im nächsten Zustand invertiert sein und 
\begin_inset Formula $a$
\end_inset

 bleibt unverändert\SpecialChar \@.

\end_layout

\begin_layout Standard
Ausgehend vom Startzustand in dem 
\begin_inset Formula $a$
\end_inset

 falsch ist wird für den ersten Schritt der obere Teil von 
\begin_inset Formula $Next$
\end_inset

 aus\SpecialChar \-
ge\SpecialChar \-
wer\SpecialChar \-
tet\SpecialChar \@.
 Der Wert der Variable 
\begin_inset Formula $a$
\end_inset

 wird somit wahr\SpecialChar \@.
 Für alle folgenden Schritte kann immer nur noch der untere
 Teil der Disjunktion 
\begin_inset Formula $Next$
\end_inset

 ausgewertet werden, da 
\begin_inset Formula $a$
\end_inset

 wahr ist und seinen Wert auch nicht mehr ändert\SpecialChar \@.
 In diesen folgenden Schritten,
 wechselt 
\begin_inset Formula $b$
\end_inset

 immer zwischen Wahr und Falsch\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Spezifikation des Modells (
\begin_inset Formula $Spec$
\end_inset

) wird gemäß des oben erwähnten Formates aufgestellt\SpecialChar \@.
 
\end_layout

\begin_layout Standard
Die zu prüfenden Eigenschaften bzw.
 Anforderungen sind in Form der Invariante (
\begin_inset Formula $Invariant$
\end_inset

) spezifiziert, die aussagt, das entweder 
\begin_inset Formula $a$
\end_inset

 oder 
\begin_inset Formula $b$
\end_inset

 wahr sein müssen\SpecialChar \@.
 Das Theorems sagt aus, dass aus der Spezifikation des
 Modells (
\begin_inset Formula $Spec$
\end_inset

) folgt, dass notwendig (
\begin_inset Formula $\Box$
\end_inset

) die Invariante gillt, die Invariante also für Jeden Zustand gelten soll\SpecialChar \@.

\end_layout

\begin_layout Standard
Es soll notwendig 
\begin_inset Formula $a$
\end_inset

 oder 
\begin_inset Formula $b$
\end_inset

 gelten oder anders formuliert
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Formula $\Box(a\lor b)=\neg\lozenge(\neg a\land\neg b)$
\end_inset


\end_layout

\end_inset

 soll nie der Fall eintreten, in dem sowohl 
\begin_inset Formula $a$
\end_inset

 als auch 
\begin_inset Formula $b$
\end_inset

 falsch sind\SpecialChar \@.

\end_layout

\begin_layout Standard
Da das beschriebene Modell aus der 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-TLA"

\end_inset

 den Zustand in dem weder 
\begin_inset Formula $a$
\end_inset

 noch 
\begin_inset Formula $b$
\end_inset

 gelten nie erreicht, Entspricht das beschriebene Modell den Anforderungen\SpecialChar \@.

\end_layout

\begin_layout Section
Code Transformation
\begin_inset CommandInset label
LatexCommand label
name "sec:Grundlagen_Code-Transformation"

\end_inset


\end_layout

\begin_layout Standard
Unter Code Transformation versteht man im Allgemeinen die Übertragung von
 Code einer formalen Sprache in den Code einer anderen formalen Sprache
 unter Beibehaltung der Semantik\SpecialChar \@.
 Ein Code-Transformator parst wie ein Compiler
 die Eingabesprache und erzeugt eine Ausgabe in der gewünschten Form\SpecialChar \@.

\end_layout

\begin_layout Standard
Für die Implementierung eines Code-Transformators bietet sich eine homoikonizitä
re
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Homoikonizität bezeichnet die Eigenschaft einer Sprache, die Datenstrukturen
 und den Programmcode im selben Format darzustellen\SpecialChar \@.
 Die Unterscheidung findet
 lediglich durch unterschiedliche Interpretationen statt\SpecialChar \@.

\end_layout

\end_inset

 und erweiterbare Sprache wie Scheme an, da lediglich mit einfachen Erweiterunge
n der Sprache gearbeitet werden kann\SpecialChar \@.
 Das trifft im Besonderen zu, wenn die
 Eingabesprache dasselbe Format hat\SpecialChar \@.
 Ein in Scheme implementierter Transformator
 würde ReActor in Form einer an Scheme angelehnten Präfixnotation einlesen
 und daraus eine TLA+ Spezifikation erzeugen (
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Code-Transformation-Scheme"

\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Code Transformation mit Scheme 
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-Transformation-Scheme"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=4cm,
\end_layout

\begin_layout Plain Layout

 box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (RA) {ReActor in 
\backslash

\backslash
 Präfixnotation};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, fill=lightgray] (CT) [right=1cm of RA] {Transformator 
\backslash

\backslash
 in Scheme};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (TLA) [right=1cm of CT] {Ausgabe 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (RA) to node {} (CT);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (CT) to node {} (TLA);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eine weitere Möglichkeit der Code Transformation besteht in der Verwendung
 von XSLT
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
XSLT ist zwar ebenfalls homoikonizitär, aber es bestehen dadurch in diesem
 Zusammenhang keine Vorteile\SpecialChar \@.
 Nicht der Compiler sondern nur die Transformationsr
egeln werden in XSLT geschrieben\SpecialChar \@.

\end_layout

\end_inset

\SpecialChar \@.
 Hierbei werden lediglich Transformationsregeln for\SpecialChar \-
ma\SpecialChar \-
li\SpecialChar \-
siert, die beschreiben,
 wie die Eingabesprache interpretiert, verarbeitet und wieder ausgegeben
 werden soll, wie in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Code-Transformation-XSLT"

\end_inset

 beschrieben\SpecialChar \@.
 Hierbei muss die Eingabesprache in XML sein\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Code Transformation mit XSLT 
\begin_inset CommandInset label
LatexCommand label
name "fig:Code-Transformation-XSLT"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=4cm,
\end_layout

\begin_layout Plain Layout

 box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (CT)  {XSLT Prozessor};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (RA) [left=1cm of CT] {ReActor 
\backslash

\backslash
 in XML};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (X) [below=0.6cm of CT] {XSLT Regeln};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round] (TLA) [right=1cm of CT] {Ausgabe 
\backslash

\backslash
 in TLA+};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (T) [above=0.3cm of CT] {Transformator};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (RA) to node {} (CT);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (X) to node {} (CT);
\end_layout

\begin_layout Plain Layout

  
\backslash
draw[->] (CT) to node {} (TLA);
\end_layout

\begin_layout Plain Layout

  
\backslash
node[rectangle,draw,dotted,fit={(T)
\end_layout

\begin_layout Plain Layout

                                   ($(CT.south west)+(-0.2cm,0)$)
\end_layout

\begin_layout Plain Layout

                                   ($(CT.south east)+(+0.1cm,0)$)
\end_layout

\begin_layout Plain Layout

                                   ($(X.south west)+(0,-0.1cm)$)
\end_layout

\begin_layout Plain Layout

                                  }] {};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Entweder wird der Transformator komplett in Scheme implementiert (siehe
 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Code-Transformation-Scheme"

\end_inset

) oder die Transformation wird durch XSLT Regeln formuliert (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Code-Transformation-XSLT"

\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Verwendung von Scheme hat den Vorteil, dass der Code übersichtlicher
 wird, allerdings würde hierbei die Transformation vollständig in Scheme
 implementiert werden\SpecialChar \@.
 XML hat den Vorteil, dass lediglich die Transformationsreg
eln geschrieben werden müssen, dafür ist XML bei gleichem Informationsgehalt
 umfangreicher\SpecialChar \@.

\end_layout

\begin_layout Standard
Je nachdem welcher Ansatz gewählt wird unterscheidet sich die Codierung
 von ReActor\SpecialChar \@.

\end_layout

\begin_layout Chapter
Lösungsansatz
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Chapter
ReActor
\begin_inset CommandInset label
LatexCommand label
name "chap:ReActor"

\end_inset


\end_layout

\begin_layout Standard
ReActor
\begin_inset CommandInset citation
LatexCommand cite
key "burmeister2013a"

\end_inset

 ist eine deklarative Spezifikationssprache zur Beschreibung von Aktormodellen\SpecialChar \@.

 Die Beschreibung orientiert sich dabei an den Möglichkeiten von TLA+\SpecialChar \@.
 Mit
 ReActor wird ein Modell definiert, welches mehrere Aktor-Klassen enthält,
 deren Instanzen gemäß der Semantik von ReActor miteinander interagieren\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Beschreibung eines Aktors besteht dabei aus der Spezifizierung des Initialzu
standes und der Deklaration von Zustandsübergängen (Schritten) die Ereignisse
 und Operationen beschreiben\SpecialChar \@.
 Ereignisse können unabhängig von eingehenden
 Nachrichten eintreten, Operationen werden nur im Zusammenhang mit einer
 eingehenden Nachricht evaluiert\SpecialChar \@.

\end_layout

\begin_layout Standard
[fülltext]
\end_layout

\begin_layout Standard
Um zwischen den beiden Möglichkeiten der Notation für ReActor die in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grundlagen_Code-Transformation"

\end_inset

 erwähnt werden zu wählen reicht ein kurzer Blick auf ein kleines Beispiel\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/usr/uni/diplom/reactor/if.xml"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={If-Klausel in XML},frame=lrtb,label={if-xml},language=XML,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Um in XML die strukturelle Information unter zu bringen wie in der schemeähnlich
en Präfixnotation wird mehr Text benötigt, was das ganze unübersichtlicher
 werden lässt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/usr/uni/diplom/reactor/if.scm"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={If-Klausel in Präfixnotation},frame=lrtb,label={if-scm},language=Lisp,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Nach diesem kurzen Blick wird ohne weitergehende Begründung die Variante
 gewählt die ReActor in Präfixnotation favorisiert\SpecialChar \@.

\end_layout

\begin_layout Section
Einschränkungen
\begin_inset CommandInset label
LatexCommand label
name "sec:ReActor-Einschränkungen"

\end_inset


\end_layout

\begin_layout Standard
Bei der Spezifikation des allgemeinen Ausführungsmodells ist folgende Formulieru
ng 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unbound_predicate"

\end_inset

 verwendet, die zwar in TLA+ beschrieben, aber nicht durch TLC berechnet
 werden kann (
\begin_inset CommandInset citation
LatexCommand cite
key "lamport2002a"

\end_inset

 Abschnitt 14.6 Seite 262)\SpecialChar \@.

\end_layout

\begin_layout Standard
Der Nachfolgezustand eines Aktors wird in ReActor durch ein Prädikat 
\begin_inset Formula $P$
\end_inset

 spezifiziert\SpecialChar \@.
 Um von einem beliebigen Prädikat auf Aussagen über die neuen
 Werte der Variablen 
\begin_inset Formula $x,y$
\end_inset

 zu gelangen sieht die Formel so aus:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\E x,y:P(x,y)\label{eq:unbound_predicate}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Diese Formel ist zwar korrekt, aber eine Berechnung aller möglichen Belegungen
 von 
\begin_inset Formula $x,y$
\end_inset

 wäre nicht entscheidbar, da die möglichen Belegungen für die Variablen
 
\begin_inset Formula $x,y$
\end_inset

 beliebig und nicht durch einen Typen beschränkt sind, und die möglichen
 Zustände somit unendlich sind\SpecialChar \@.

\end_layout

\begin_layout Standard
Ein möglicher Ansatz zur Lösung dieses Problems wäre die drastische Einschränkun
g der Ausdrucksmöglichkeit des Prädikates, um anstelle eines allgemeinen
 Prädikates konkrete Belegungen zu spezifizieren\SpecialChar \@.
 Dies könnte beispielsweise
 durch eine disjunktive Normalform (DNF) nach folgendem Schema funktionieren:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\begin{array}{cccccc}
P(x,y)\defeq & \land & \lor & x & = & B_{x,1}\\
 &  & \lor & y & = & B_{y,1}\\
 &  &  &  & \vdots\\
 & \land & \lor & x & = & B_{x,n}\\
 &  & \lor & y & = & B_{y,n}
\end{array}\label{eq:restricted_P}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Eine DNF hätte dieselbe Aussagemöglichkeit wie jede andere Formel allerdings
 ohne Quantoren\SpecialChar \@.
 Allerdings wäre in diesem Fall durch die Begrenztheit der
 gegebenen Formel eine Entscheidbarkeit von 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:unbound_predicate"

\end_inset

 gegeben\SpecialChar \@.

\end_layout

\begin_layout Standard
Ein weiterer Lösungsansatz ist die Beschränkung der Variablen in der Formel
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:unbound_predicate"

\end_inset

 auf Werte aus endlichen Mengen:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
x,y\in\left\{ 1,\dots\text{,n}\right\} :P(x,y)\label{eq:restricted_types}
\end{equation}

\end_inset

mit 
\begin_inset Formula $n\in\mathbb{{N}}$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
Um die Mächtigkeit der Aussagen so zu beschränken, dass die Berechenbarkeit
 gegeben ist, darf keine Quantifizierung über unendliche Mengen erfolgen\SpecialChar \@.

 Dies wird entweder durch Einschränkung der Ausdrucksmöglichkeit des Prädikates
 
\begin_inset Formula $P$
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:restricted_P"

\end_inset

 oder Einschränkung des Wertebereichs der Zustandsvariablen auf endliche
 Mengen
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:restricted_types"

\end_inset

 erreicht\SpecialChar \@.

\end_layout

\begin_layout Standard
Um die Ausdrucksmöglichkeit von 
\begin_inset Formula $P$
\end_inset

 in ReActor nicht einschränken zu müssen, wird für die Spezifizierung von
 Aktoren die Einschränkung des Wer\SpecialChar \-
te\SpecialChar \-
be\SpecialChar \-
reichs gewählt\SpecialChar \@.
 Dies hat zur Folge,
 dass verwendete Variablen typisiert werden müssen\SpecialChar \@.
 Außerdem muss beim Model-Chec
king eine Begrenzung von unbegrenzten Mengen wie 
\begin_inset Formula $\mathbb{N}$
\end_inset

, 
\begin_inset Formula $\mathbb{Q}$
\end_inset

 und anderen stattfinden\SpecialChar \@.
 Die Typisierung in Kombination mit der Begrenzung
 der Menge gibt dem Modellprüfer endliche Grenzen zur Exploration\SpecialChar \@.

\end_layout

\begin_layout Standard
In gleicher Weise werden werden Sequenzen in ihrer Länge beschränkt, da
 sie theoretisch unendlich lang werden können\SpecialChar \@.

\end_layout

\begin_layout Section
Notation
\end_layout

\begin_layout Standard
[Einleitender Absatz]
\end_layout

\begin_layout Standard
Vorausgesetzt wird ein grundlegendes Verständnis der Programmierung (Objektorien
tierung, Rekursion, etc.) und Kenntnis des Aktor-Objekt-Modells im speziellen
 ReActor\SpecialChar \@.

\end_layout

\begin_layout Standard
Jede Aktorklasse hat einen Namen(
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
name
\end_layout

\end_inset

), der eindeutig definiert ist\SpecialChar \@.
 Zur Initialisierung eines Aktormodells wird
 eine Instanz des Aktors mit dem Namen 
\begin_inset Quotes eld
\end_inset

environment
\begin_inset Quotes erd
\end_inset

 erstellt und initialisiert\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/class.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Aktor Klasse},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={actor-class},language=ReActor,morekeywords={[9]{name}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Subsection
Datentypen
\begin_inset CommandInset label
LatexCommand label
name "sub:ReActor-Datentypen"

\end_inset


\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

 Für Bedingungen und Aussagen ist der Typ 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph off
bool
\end_layout

\end_inset

 eingeführt, der die Werte wahr und falsch annehmen kann (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:particular-values"

\end_inset

)\SpecialChar \@.
 
\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

 Der Einfachheitshalber sind die Werte mit denen operiert wird auf ganze
 Zahlen (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph off
nat
\end_layout

\end_inset

) beschränkt\SpecialChar \@.
 
\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
ref
\end_layout

\end_inset

 Referenzen auf Aktoren stellen einen Spezialtyp dar, der von 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
int
\end_layout

\end_inset

 verschieden sein soll\SpecialChar \@.
 Die Menge der 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
actor
\begin_inset space ~
\end_inset

id
\end_layout

\end_inset

s wird vom Modellierer explizit konfiguriert\SpecialChar \@.

\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

 Für zusammenfassende Datentypen bzw.
 Mengen ist der Typ 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

 vorgesehen, in dem Werte aller anderen Datentypen enthalten sein können\SpecialChar \@.

 Eine Menge kann leer sein (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:particular-values"

\end_inset

)\SpecialChar \@.
 Der Datentyp set kann aus Komplexitätsgrunden (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:ReActor-Einschränkungen"

\end_inset

) derzeit nicht für zustandsvariablen von Aktoren verwendet werden\SpecialChar \@.

\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
sequence
\end_layout

\end_inset

 Zusammenfassender Datentypen der aus einer Sequenz von Werten eines bestimmten
 Typs besteht\SpecialChar \@.
 Eine Sequenz kann leer sein (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:particular-values"

\end_inset

)\SpecialChar \@.
 Der Typ wird in der Form 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(sequence 
\emph on
type
\emph default
)
\end_layout

\end_inset

 angegeben\SpecialChar \@.
 Eine Sequenz von Zahlen wird beispielsweise als 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(sequence nat)
\end_layout

\end_inset

 geschrieben\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Wert
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\top$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
#t
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wahr
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bot$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
#f
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
falsch
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
emptyset
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
leere Menge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\langle\rangle$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
emtpy-sequence
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
leere Sequenz
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Besondere Werte
\begin_inset CommandInset label
LatexCommand label
name "tab:particular-values"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operationen
\end_layout

\begin_layout Standard
Auf den oben genannten Datentypen sind Operationen definiert, die in diesem
 Abschnitt näher erläutert sind\SpecialChar \@.
 Sofern nicht anders gekennzeichnet handelt
 es sich bei der Schreibweise in TeX um infixnotation (
\begin_inset Formula $a\times b$
\end_inset

) und bei der Schreibweise in ASCII um präfixnotation (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(x a b)
\end_layout

\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Boolean
\end_layout

\begin_layout Standard
Ein Wert vom Typ 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

 ergibt sich durch die Operationen 
\begin_inset Quotes pld
\end_inset

Und
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Oder
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

Nicht
\begin_inset Quotes prd
\end_inset

\SpecialChar \@.
 Die Operationen 
\begin_inset Quotes pld
\end_inset

Und
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

Oder
\begin_inset Quotes prd
\end_inset

 können in der ASCII schreibweise mit belibig vielen Operanten geschrieben
 werden\SpecialChar \@.
 So wird beispielsweise aus 
\begin_inset Formula $a\wedge b\wedge c$
\end_inset

 in ASCII schreibweise: 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(and a b c)
\end_layout

\end_inset

\SpecialChar \@.
 
\begin_inset Quotes pld
\end_inset

Und
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

Oder
\begin_inset Quotes prd
\end_inset

 bilden von zwei bool-Werten auf einen ab (
\begin_inset Formula $bool\times bool\rightarrow bool$
\end_inset

), 
\begin_inset Quotes pld
\end_inset

Nicht
\begin_inset Quotes prd
\end_inset

 bildet von einem bool-Wert auf einen ab(
\begin_inset Formula $bool\rightarrow bool$
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\land$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
and
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Und
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lor$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
or
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Oder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
not
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nicht
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Operationen auf 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-auf-bool"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Zahlen
\end_layout

\begin_layout Standard
Gemäß der gängigen Algebra natürlicher Zahlen sind auf dem Datentyp 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

 folgende Operationen definiert: 
\begin_inset Quotes pld
\end_inset

Plus
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Minus
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Mal
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Ganzzahldivision
\begin_inset Quotes prd
\end_inset

 und
\emph on
 
\emph default

\begin_inset Quotes pld
\end_inset

Modulo
\begin_inset Quotes prd
\end_inset

\SpecialChar \@.
 Die entsprechenden Symbole sind der nachfolgenden 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Operationen-auf-int"

\end_inset

 zu entnehmen\SpecialChar \@.
 Alle Operationen bilden von zwei 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

-Werten auf einen ab (
\begin_inset Formula $nat\times nat\rightarrow nat$
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
+
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Plus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $-$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
-
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Minus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $*$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
*
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\div$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
div
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ganzzahldivision
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\bmod$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
mod
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modulo
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Operationen auf 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-auf-int"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Operationen auf dem Datetyp 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

 die nach Werten vom Typ 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

 abbilden sind 
\begin_inset Quotes pld
\end_inset

gleich
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

größer
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

größer gleich
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

kleiner
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

kleiner gleich
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

ungleich
\begin_inset Quotes prd
\end_inset

\SpecialChar \@.
 Diese Operationen folgen ebenfalls der allgemein üblichen Interpretation\SpecialChar \@.

 Die entsprechenden Symbole sind der nachfolgenden 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Operationen-von-nat-nach-bool"

\end_inset

 zu entnehmen\SpecialChar \@.
 Alle Operationen bilden von zwei 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

-Werten auf einen 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

-Wert ab (
\begin_inset Formula $nat\times nat\rightarrow bool$
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gleich
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
>
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
größer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\geq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
>=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
größer gleich
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $<$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
größer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
<=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
größer gleich
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\not=$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
!=
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ungleich
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Operationen von 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
nat
\end_layout

\end_inset

 nach 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-von-nat-nach-bool"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Mengen
\end_layout

\begin_layout Standard
Eine Menge kann durch Aufzählung der Elemente konstruiert werden\SpecialChar \@.
 Das geschieht
 mit dem Operator 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
enum->set
\end_layout

\end_inset

\SpecialChar \@.
 Eine Menge mit den Elementen 
\begin_inset Quotes pld
\end_inset

a
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

b
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

c
\begin_inset Quotes prd
\end_inset

 (
\begin_inset Formula $\{a,b,c\}$
\end_inset

) wird dargestellt als: 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(enum->set a b c)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf Mengen sind die Operationen 
\begin_inset Quotes pld
\end_inset

Vereinigung
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Schnitt
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

Differenz
\begin_inset Quotes prd
\end_inset

 gemäß der allgemein ver\SpecialChar \-
brei\SpecialChar \-
te\SpecialChar \-
ten Mengenalgebra definiert\SpecialChar \@.
 Die entsprechenden
 Symbole sind der nachfolgenden 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Operationen-auf-sequence"

\end_inset

 zu entnehmen\SpecialChar \@.
 Alle Operationen bilden von zwei Mengen auf eine ab (
\begin_inset Formula $set\times set\rightarrow set$
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\cup$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set-union
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vereinigung
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\cap$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set-intersection
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Schnitt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\setminus$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set-difference
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Differenz
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Operationen auf 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-auf-set"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ebenfalls ergeben sich boolesche Werte, wenn folgende Operationen auf Werten
 vom Typ 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

 ausge\SpecialChar \-
wertet werden: 
\begin_inset Quotes pld
\end_inset

echte Teilmenge
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Teil\SpecialChar \-
menge
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

echte Obermenge
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Obermenge
\begin_inset Quotes prd
\end_inset

, 
\begin_inset Quotes pld
\end_inset

Element aus
\begin_inset Quotes prd
\end_inset

 und 
\begin_inset Quotes pld
\end_inset

kein Element aus
\begin_inset Quotes prd
\end_inset

\SpecialChar \@.
 Die entsprechenden Symbole sind der nachfolgenden 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Operationen-von-set-nach-bool"

\end_inset

 zu entnehmen\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\subset$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
propper-subset
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
echte Teilmenge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\subseteq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
subset
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Teilmenge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\supset$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
propper-supset
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
echte Obermenge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\subseteq$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
supset
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Obermenge
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\in$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
element-of
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Element aus
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\notin$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
no-element-of
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keine Element aus
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Operationen von 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

 nach 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-von-set-nach-bool"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alle Operationen mit Ausnahme der letzten beiden bilden von zwei Mengen
 auf einen 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

-Wert ab (
\begin_inset Formula $set\times set\rightarrow bool$
\end_inset

)\SpecialChar \@.
 Die beiden zu letzt aufgeführten Operationen bilden von Element und Menge
 auf einen 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
bool
\end_layout

\end_inset

-Wert ab (
\begin_inset Formula $item\times set\rightarrow bool$
\end_inset

)\SpecialChar \@.
 Ein Element kann hierbei von jedem Typ sein, es bietet sich allerdings
 an nur Elemente eines Typs zu nutzen\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Sequenzen
\end_layout

\begin_layout Standard
Auf Sequenzen sind Operationen zur Inspektion und Manipulation von Sequenzen
 definiert\SpecialChar \@.
 Die Operation 
\begin_inset Quotes pld
\end_inset

Length
\begin_inset Quotes prd
\end_inset

 bestimmt die Länge einer gegebenen Sequenz\SpecialChar \@.
 Append hängt einer Sequenz 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
s
\end_layout

\end_inset

 ein Element 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 an\SpecialChar \@.
 Die Konkatenation verbindet die beiden Übergebenen Listen 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
s
\end_layout

\end_inset

 und 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
t
\end_layout

\end_inset

 zu einer Liste\SpecialChar \@.
 Head liefert das erste Element der Sequenz 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
s
\end_layout

\end_inset

\SpecialChar \@.
 Tail liefert eine Sequenz, die alle Elemente außer dem Ersten der gegebenen
 Sequenz 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
s
\end_layout

\end_inset

 enthält\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
ASCII
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Signatur
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Length(s)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(length s)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Länge von
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $seq\rightarrow nat$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Append(s,e)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(append s e)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anhängen
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $seq\times element\rightarrow seq$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $s\circ t$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(concat s t)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Konkatenation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $seq\times seq\rightarrow seq$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Head(s)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(head s)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kopf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $seq\rightarrow element$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Tail(s)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(tail s)
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rest
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $seq\rightarrow seq$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Operationen auf 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
sequence
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:Operationen-auf-sequence"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "tab:Operationen-auf-sequence"

\end_inset

 stehen 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
s
\end_layout

\end_inset

 und 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
t
\end_layout

\end_inset

 für Mengen und 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
e
\end_layout

\end_inset

 für ein Element\SpecialChar \@.

\end_layout

\begin_layout Subsection
Deklarationen
\end_layout

\begin_layout Standard
Konstanten und Variablen werden durch eine einfache Auflistung von Be\SpecialChar \-
zeich\SpecialChar \-
nern
 durch den Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
constant
\end_layout

\end_inset

 oder 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
constants
\end_layout

\end_inset

 bzw.
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
variable
\end_layout

\end_inset

 oder 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
variables
\end_layout

\end_inset

 deklariert\SpecialChar \@.

\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/constants-variables.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Deklaration von Konstanten und Variablen},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={constants-variables},language=ReActor,morekeywords={[9]{type1,var1,typeN,varN}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Der Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
assume
\end_layout

\end_inset

 wird verwendet, um Annahmen über Konstanten zu treffen und so ihre möglichen
 Werte einzugrenzen\SpecialChar \@.
 Der Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
invariant
\end_layout

\end_inset

 legt Invarianten mit Namen und booleschem Ausdruck fest die den Wertebereich
 der Variablen festlegen\SpecialChar \@.
 Beide Deklarationen enthalten einen booleschen
 Ausdruck (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
boolean-expression
\end_layout

\end_inset

).
 
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/assume-invariant.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Deklaration von Annahmen und Invarianten},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={variables-1},language=ReActor,morekeywords={[9]{boolean-expression}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Bekannte Aktoren werden durch Angabe einer Menge (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
set
\end_layout

\end_inset

) durch den Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
acquaintances
\end_layout

\end_inset

 deklariert\SpecialChar \@.

\end_layout

\begin_layout Standard
Der nach außen sichtbare Status wird durch einen beliebigen Wert im Ausdruck
 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
public-state
\end_layout

\end_inset

 deklariert\SpecialChar \@.
 Der initiale Status wird durch den boole\SpecialChar \-
schen Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
init-predicate
\end_layout

\end_inset

 deklariert\SpecialChar \@.

\end_layout

\begin_layout Subsection
Sprachliche Konstrukte
\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
new
\end_layout

\end_inset

 Der Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
new
\end_layout

\end_inset

 dient der Erzeugung und Initialisierung neuer Aktoren\SpecialChar \@.
 Mit dem Ausduck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
new
\end_layout

\end_inset

 kann eine beliebige Anzal von Aktoren erzeugt werden\SpecialChar \@.
 Die Argumentliste
 zur Erzeugung der Aktoren werden einfach aneinander gereiht\SpecialChar \@.
 Wenn kein Aktor
 erzeugt werde soll bleibt diese Liste einfach leer\SpecialChar \@.
 Das erste Argument (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
acotr-type
\end_layout

\end_inset

) ist der Name der Aktorklasse, der instantiiert werden soll\SpecialChar \@.
 Das zweite
 Argument (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
actor-id
\end_layout

\end_inset

) gibt die AktorId des neuen Aktors an\SpecialChar \@.
 Anschließend folgt eine Liste mit
 Tupeln aus Variablennamen (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
var1
\emph default
 … 
\emph on
varN
\end_layout

\end_inset

) und Werten (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
val1
\emph default
 … 
\emph on
valN
\end_layout

\end_inset

), die festlegt, welche Variablen des neuen Aktors welchen Initialwert zugewiese
n bekommen sollen\SpecialChar \@.
 Die Zuweisung darf nicht dem 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
init-predicate
\end_layout

\end_inset

 der Aktorklasse des neuen Aktors widersprechen\SpecialChar \@.

\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/new.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={new-Prädikat},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={predicate-new},language=ReActor,morekeywords={[9]{actor-type,actor-id,var1,val1,varN,valN}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
send
\end_layout

\end_inset

 Der Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
send
\end_layout

\end_inset

 schickt beliebig viele Nachrichten an beliebige Aktoren, die Argumentlisten
 zur Erzeugung der Nachrichten werden einfach aneinander gereiht\SpecialChar \@.
 Das erste
 Argument (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
amount
\end_layout

\end_inset

) ist die Anzahl der Nachrichten, die verschickt werden sollen\SpecialChar \@.
 Das zweite
 Argument (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
name
\end_layout

\end_inset

) gibt den Namen der Nachricht an, gefolgt von einer Liste von Parametern
 samt Werten (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
((
\emph on
var1
\emph default
 
\emph on
val1
\emph default
) … (
\emph on
varN
\emph default
 
\emph on
valN
\emph default
))
\end_layout

\end_inset

) die mit der Nachricht gesendet werden sollen\SpecialChar \@.
 Als letztes wird die ID des
 Ziel-Aktors angegeben\SpecialChar \@.

\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/send.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={send-Prädikat},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={predicate-send},language=ReActor,morekeywords={[9]{amount,name,target-actor,var1,val1,varN,valN}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
@
\end_layout

\end_inset

 Der Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
@
\end_layout

\end_inset

 wählt eine feste aber beliebige Adresse aus dem Pool der noch freien Adresse
 aus\SpecialChar \@.
 Das Argument (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
number
\end_layout

\end_inset

) lässt zwischen verschiedenen Adressen unterscheiden\SpecialChar \@.
 Zu Beispiel hat 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
(@ 2)
\end_layout

\end_inset

 Innerhalb eines Prädikates während eines Schrittes stets den selben Wert\SpecialChar \@.

\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/at.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={@-Prädikat},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={predicate-at},language=ReActor,morekeywords={[9]{number}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Subsubsection
Modifikatoren
\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
pre
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
post
\end_layout

\end_inset

 Variablen, die sich innerhalb einer Aktion verändern sollen, werden mit
 den Ausdrücken 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
pre
\end_layout

\end_inset

 und 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
post
\end_layout

\end_inset

 versehen\SpecialChar \@.
 Der Wert vor der Aktion wird mit 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
pre
\end_layout

\end_inset

 und der Wert nach der Aktion wird mit 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
post
\end_layout

\end_inset

 gekennzeichnet\SpecialChar \@.

\end_layout

\begin_layout Description
unchanged Variablen, die durch eine Aktion nicht veränderb, werden mit dem
 Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
unchanged
\end_layout

\end_inset

 versehen
\end_layout

\begin_layout Subsubsection
Spezialvariablen
\end_layout

\begin_layout Description
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
self
\end_layout

\end_inset

 Die Adresse des eigenen Aktors, wird verwendet um Nachrichten an sich selbst
 zu senden\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Bedingungen
\end_layout

\begin_layout Standard
Für die bedingte Formeln wird ein If-Ausdruck(
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
if
\end_layout

\end_inset

) eingeführt, der sich an der Notation von Scheme orientiert\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Aktivitäten
\end_layout

\begin_layout Standard
Aktivitäten teilen sich in Operationen und Events auf\SpecialChar \@.
 Beide bilden den den
 
\begin_inset Quotes eld
\end_inset

Rumpf
\begin_inset Quotes erd
\end_inset

 des Aktors\SpecialChar \@.

\end_layout

\begin_layout Standard
In einer Operation (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
operation
\end_layout

\end_inset

) wird die Situation spezifiziert, die in Zusammenhang mit an den Aktor
 gesendeten Nachrichten steht\SpecialChar \@.
 Operationen haben einen Bezeichner (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
name
\end_layout

\end_inset

), dieser entspricht dem Namen der eingehenden Nachricht, die verarbeitet
 werden soll\SpecialChar \@.
 Nach dem Namen steht Liste von Argumenten (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
((
\emph on
type1
\emph default
 
\emph on
var1
\emph default
) … (
\emph on
typeN
\emph default
 
\emph on
varN
\emph default
))
\end_layout

\end_inset

), die mit der Nachricht übergeben werden\SpecialChar \@.
 Zusetzt stehen zwei booleschen
 Aüsdrucke, einer der festlegt, unter welchen Bedingungen die Operation
 nicht ausgewertet werden soll (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
guard-expression
\end_layout

\end_inset

) und einer, der zur Evaluation der Operation ausgewertet wird (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout

\emph on
evaluation-expression
\end_layout

\end_inset

)\SpecialChar \@.
 Alle Operationen werden durch den Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
operations
\end_layout

\end_inset

 zusammengefasst\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/operations.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Operationen},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={operations},language=ReActor,morekeywords={[9]{name,type1,var1,typeN,varN,guard-expression,evaluation-expression}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Ein Ereigniss(
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
event
\end_layout

\end_inset

) ist eine Operation, die unabhängig von Nachrichten ausgewertet wird\SpecialChar \@.
 Ereignisse
 gleichen im prinzip einer Operation mit dem einzigen Unterschied, dass
 keine Nachricht notwendig ist um ein Ereigniss auszuwerten\SpecialChar \@.
 Daher entfällt
 bei der Notation eines Ereignisses die Liste der Argumente\SpecialChar \@.
 Alle Events
 werden durch den Ausdruck 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
events
\end_layout

\end_inset

 zusammengefasst\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/reactor/events.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Events},frame=ltb,keywordstyle={[9]{\\color{gray}\\itshape}},label={events},language=ReActor,morekeywords={[9]{name,guard-expression,evaluation-expression}},numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Section
Beispielcode
\end_layout

\begin_layout Standard
Dies ist eine beispielhafte Beschreibung einer Teilmenge von ReActor\SpecialChar \@.
 Die
 Teilmenge ist so gewählt, dass sie ausreicht ein einfaches Beispiel zu
 beschreiben\SpecialChar \@.
 In dem gewählten Beispiel geht es um die 
\begin_inset Quotes eld
\end_inset

rekursive
\begin_inset Quotes erd
\end_inset

 Berechnung der Fakultät, unter Verwendung von Aktoren für jeden einzelnen
 Rekursionsschritt\SpecialChar \@.

\end_layout

\begin_layout Standard
Die aktorbasierte Variante der Fakultätsberechnung wurde folgendermaßen
 implementiert: Der erste Aktor wird initialisiert mit dem Wert für den
 die Fakultät berechnet werden soll\SpecialChar \@.
 Dieser wiederum merkt sich seinen Wert
 und die Adresse des anfragenden Aktors und initialisiert den nächsten Aktor
 mit einem um eins verringerten Wert\SpecialChar \@.
 Diese Initialisierungskette setzt sich
 so lange fort, bis der Parameter zur Berechnung den Wert 1 erreicht hat\SpecialChar \@.

\end_layout

\begin_layout Standard
Wenn ein Aktor merkt, dass er der Letzte in der Kette ist, sendet er eine
 Nachricht mit dem Wert 1 an den Aktor, der ihn erstellt hat\SpecialChar \@.
 Empfängt ein
 Aktor einen Wert, multipliziert er seinen eigenen Wert zu dem Empfangenen
 und sendet das Resultat an den Aktor, der ihn erstellt hat und so weiter\SpecialChar \@.

\end_layout

\begin_layout Standard
Siehe: Anhang 
\begin_inset CommandInset ref
LatexCommand vref
reference "environment-actor"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand vref
reference "factorial-step-actor"

\end_inset


\end_layout

\begin_layout Section
Grammatik
\end_layout

\begin_layout Standard
Siehe: Anhang
\begin_inset CommandInset ref
LatexCommand nameref
reference "ReActor-EBNF"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Marginal
status open

\begin_layout Plain Layout
TODO: Interessante Aspekte der Grammatik herausnehmen und Erläutern\SpecialChar \@.

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Grammatik soll mit Kommentaren versehen werden, die alle Aspekte noch
 genauer erläutert sobald die Grammatik endgültig feststeht\SpecialChar \@.
 So könnte eine
 mögliche Visuali\SpecialChar \-
sierung einer Regel aussehen:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

    >=latex,thick,
\end_layout

\begin_layout Plain Layout

    /pgf/every decoration/.style={/tikz/sharp corners},
\end_layout

\begin_layout Plain Layout

    fuzzy/.style={decorate,
\end_layout

\begin_layout Plain Layout

        decoration={random steps,segment length=0.5mm,amplitude=0.15pt}},
\end_layout

\begin_layout Plain Layout

    minimum size=6mm,line join=round,line cap=round,
\end_layout

\begin_layout Plain Layout

    terminal/.style={rectangle,draw,fill=white,fuzzy,rounded corners=3mm},
\end_layout

\begin_layout Plain Layout

    nonterminal/.style={rectangle,draw,fill=white,fuzzy},
\end_layout

\begin_layout Plain Layout

    node distance=4mm
\end_layout

\begin_layout Plain Layout

  ]
\end_layout

\begin_layout Plain Layout

   
\backslash
ttfamily
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{scope}[start chain,
\end_layout

\begin_layout Plain Layout

            every node/.style={on chain},
\end_layout

\begin_layout Plain Layout

            terminal/.append style={join=by {->,shorten >=-1pt,
\end_layout

\begin_layout Plain Layout

                fuzzy,decoration={post length=4pt}}},
\end_layout

\begin_layout Plain Layout

            nonterminal/.append style={join=by {->,shorten >=-1pt,
\end_layout

\begin_layout Plain Layout

                fuzzy,decoration={post length=4pt}}},
\end_layout

\begin_layout Plain Layout

            support/.style={coordinate,join=by fuzzy}
\end_layout

\begin_layout Plain Layout

        ]
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (start)         {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [terminal]                            {(};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [terminal]                            {class};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [nonterminal]                         {identifier};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (decl skip s)   {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (decl repeat t) {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [nonterminal]                         {declaration};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (decl repeat s) {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (decl skip t)   {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (event skip s)  {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (event repeat t){};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [nonterminal]                         {event};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (event repeat s){};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support]             (event skip t)  {};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [terminal]                            {)};
\end_layout

\begin_layout Plain Layout

        
\backslash
node [support,join=by ->]  (end)           {};
\end_layout

\begin_layout Plain Layout

    
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
begin{scope}[->,decoration={post length=4pt},rounded corners=2mm,
\end_layout

\begin_layout Plain Layout

            every path/.style=fuzzy]
\end_layout

\begin_layout Plain Layout

        
\backslash
draw (decl repeat s) -- +(0,+.7) -| (decl repeat t);
\end_layout

\begin_layout Plain Layout

        
\backslash
draw (decl skip s)   -- +(0,-.7) -| (decl skip t);
\end_layout

\begin_layout Plain Layout

        
\backslash
draw (event repeat s) -- +(0,+.7) -| (event repeat t);
\end_layout

\begin_layout Plain Layout

        
\backslash
draw (event skip s)   -- +(0,-.7) -| (event skip t);
\end_layout

\begin_layout Plain Layout

    
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout


\backslash
caption{actor} 
\backslash
label{fig:actor}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Allgemeines Ausführungsmodell
\begin_inset CommandInset label
LatexCommand label
name "chap:Allgemeines-Ausführungsmodell"

\end_inset


\end_layout

\begin_layout Standard
Das allgemeine Ausführungsmodell ist ein Modell eines Aktor-Systems, das
 mit dem TLC-Modellprüfer überprüft werden soll\SpecialChar \@.
 Wie be\SpecialChar \-
reits in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Grundlagen"

\end_inset

 beschrieben besteht dieses Modell aus zwei Teilen\SpecialChar \@.
 Ein Teil beschreibt das
 allgemeine Verhalten des Ausführungsmodells, das für alle Aktorsysteme
 gleich bleibt.
 Der andere Teil beschreibt die Aktoren, die für jedes Aktorsystem variieren
 und der aus der ReActor-Spezifikation generiert wird\SpecialChar \@.

\end_layout

\begin_layout Section
Modellierungskonzept
\end_layout

\begin_layout Standard
Der Zustand des Aktorsystems wird durch zwei Variablen repräsentiert\SpecialChar \@.
 Die
 Variable 
\begin_inset Formula $actors$
\end_inset

 ist für alle Aktoren mit ihrem aktuellen Zustand vorgesehen und die Variable
 
\begin_inset Formula $messages$
\end_inset

 beinhaltet alle gesendeten, noch nicht verarbeiteten Nachrichten\SpecialChar \@.

\end_layout

\begin_layout Subsection
Aktoren
\begin_inset CommandInset label
LatexCommand label
name "sub:Aktoren"

\end_inset


\end_layout

\begin_layout Standard
Die Variable 
\begin_inset Formula $actors$
\end_inset

 hat eine Funktion, dessen Definitionsmenge zu Beginn der Simulation noch
 leer ist\SpecialChar \@.
 Diese Funktion bildet von den Aktor-IDs (
\begin_inset Formula $ActorIDs$
\end_inset

) auf Zustand (
\begin_inset Formula $state$
\end_inset

) und Typ (
\begin_inset Formula $type$
\end_inset

) des jeweiligen Aktors ab\SpecialChar \@.

\begin_inset Formula 
\[
actors\in[ActorIDs\rightarrow[state\mapsto PossibleStates,type\mapsto PossibleTypes]]
\]

\end_inset


\end_layout

\begin_layout Standard
Wird im Laufe der Simulation ein neuer Aktor erzeugt, dann wird die Funktion
 entsprechend erweitert\SpecialChar \@.
 In ReActor ist die Anzahl der Aktorobjekte zur Laufzeit
 unbegrenzt\SpecialChar \@.
 Um diesem Sprachmerkmal in der Simulation entgegen zu kommen
 werden Aktoren, die nicht mehr für das System benötigt werden aus der 
\begin_inset Formula $actors$
\end_inset

-Funktion entfernt, um wieder Platz für neue Aktoren zu haben\SpecialChar \@.

\end_layout

\begin_layout Subsection
Nachrichten
\begin_inset CommandInset label
LatexCommand label
name "sub:Nachrichten"

\end_inset


\end_layout

\begin_layout Standard
Nachrichten, die eine Aktivität sendet, werden in keiner vorgeschriebenen
 Reihenfolge ausgewertet\SpecialChar \@.
 Deswegen werden Nachrichten, eines Aktivitätsschrittes
 in einer Bag (Multimenge) zusammengefasst\SpecialChar \@.
 Bei der Auswertung der Nachrichten
 wird immer eine beliebige Nachricht dieser Bag ausgewählt\SpecialChar \@.

\end_layout

\begin_layout Standard
Daraus ergibt sich die Nachrichten in einer Funktion zu speichern, die von
 den Ziel-IDs (
\begin_inset Formula $TargetActorIDs$
\end_inset

) auf Bags von Nachrichten (
\begin_inset Formula $Bag(PossibleMessages)$
\end_inset

) abbildet, wie in Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:id->bag(msg)"

\end_inset

 gezeigt\SpecialChar \@.
 
\begin_inset Formula 
\begin{equation}
[TargetActorIDs\rightarrow Bag(PossibleMessages)]\label{eq:id->bag(msg)}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Um die Spezifikation des Systems zu vereinfachen, werden Nach\SpecialChar \-
rich\SpecialChar \-
ten, die
 zwischen zwei bestimmten Aktoren aus verschiedenen Aktivitäten gesendet
 werden, genau in der Reihenfolge verarbeitet werden, wie sie gesendet wurden\SpecialChar \@.

 Deswegen werden die Nachrichten aus unterschiedlichen Aktivitäten in einer
 Sequenz geordnet\SpecialChar \@.
 Bei der Auswertung der Nachrichten werden nur Nachrichten
 der ersten Bag ausgewählt, erst wenn alle Nachrichten einer Bag ausgewertet
 wurden, werden Nachrichten aus der nachfolgenden Bag der Sequenz ausgewählt\SpecialChar \@.

\end_layout

\begin_layout Standard
Somit wird die Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:id->bag(msg)"

\end_inset

 um eine Sequenz ergänzt, in der die Nachrichten-Bags enthalten sind, wie
 in Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:id->seq(bag(msg))"

\end_inset

 gezeigt\SpecialChar \@.
 
\begin_inset Formula 
\begin{equation}
[TargetActorIDs\rightarrow Seq(Bag(PossibleMessages))]\label{eq:id->seq(bag(msg))}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Damit bei Nachrichten von anderen Aktoren die Zufälligkeit der Auswertungsreihen
folge immer noch gewährgeleistet ist, werden diese Sequenzen nach Sender
 und Empfänger getrennt\SpecialChar \@.
 Dadurch können Nachrichten, die von unterschiedlichen
 Aktoren gesendet wurden trotz der Sortierung der Sequenz, in zufälliger
 Reihenfolge durch den Zielaktor ausgewertet werden\SpecialChar \@.
 Es gibt für jedes Sender-Emp
fänger-Paar eine eigene Sequenz\SpecialChar \@.

\end_layout

\begin_layout Standard
Aus der Erweiterung der Formel 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:id->seq(bag(msg))"

\end_inset

 ergibt sich für den Nachrichtenpuffer eine Datenstruktur, wie in Formel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:idxid->seq(bag(msg))"

\end_inset

 dargestellt\SpecialChar \@.

\begin_inset Formula 
\begin{equation}
messages\in\left[\begin{array}{c}
SourceActorIDs\times TargetActorIDs\\
\rightarrow Seq(Bag(PossibleMessages))
\end{array}\right]\label{eq:idxid->seq(bag(msg))}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Ein Aktor kann alle Nachrichten auswerten, die sich in der jeweils ersten
 Bag aller Sequenzen der Nachrichten befinden, welche an diesen Aktor gesendet
 wurden\SpecialChar \@.

\end_layout

\begin_layout Section
Module
\end_layout

\begin_layout Standard
Zur besseren Übersichtlichkeit ist das TLA-Ausführungsmodell in einzelne
 Mo\SpecialChar \-
dule unterteilt (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Allgemeines-Ausführungsmodell"

\end_inset

)\SpecialChar \@.
 Die Pfeile bedeuten hierbei welche Module aufeinander aufbauen\SpecialChar \@.
 Beispielsweise
 fliest das Modul 
\emph on

\begin_inset Formula $Utils$
\end_inset


\emph default
 in das Modul 
\emph on

\begin_inset Formula $ActorBase$
\end_inset


\emph default
 und ist damit auch in allen anderen Modulen einbezogen\SpecialChar \@.
 Die auswechselbaren
 Elemente des Ausführungsmodells sind grau dargestellt\SpecialChar \@.
 Die direkten Repräsentati
onen der Aktoren haben abgerundete Ecken\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
Module des allgemeinen Ausführungsmodells 
\begin_inset CommandInset label
LatexCommand label
name "fig:Allgemeines-Ausführungsmodell"

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[
\end_layout

\begin_layout Plain Layout

 >=latex,thick,
\end_layout

\begin_layout Plain Layout

 node distance=3cm,
\end_layout

\begin_layout Plain Layout

  box/.style={rectangle, draw, fill=white, align=center},
\end_layout

\begin_layout Plain Layout

 round/.style={rectangle, draw, fill=white, rounded corners=3mm, align=center},
\end_layout

\begin_layout Plain Layout

 minimum size=6mm,
\end_layout

\begin_layout Plain Layout

 line join=round,
\end_layout

\begin_layout Plain Layout

 line cap=round,
\end_layout

\begin_layout Plain Layout

 auto]
\end_layout

\begin_layout Plain Layout

  {
\backslash
itshape
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AEN) {ActorBase};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, gray, fill=white] (UT) [left=1cm of AEN] {Utils};
\end_layout

\begin_layout Plain Layout

  
\backslash
node (YA) [below=1cm of AEN] {...};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (XA) [left=0.2cm of YA] {EnvironmentActor};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [round, fill=lightgray] (ZA) [right=0.2cm of YA] {OtherActor};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box, fill=lightgray] (A) [below=1cm of YA] {Actors};
\end_layout

\begin_layout Plain Layout

  
\backslash
node[rectangle,draw,gray,fit={($(XA.north west)+(-0.1cm,0.1cm)$)
\end_layout

\begin_layout Plain Layout

                                 ($(ZA.south east)+(0.1cm,0)$)
\end_layout

\begin_layout Plain Layout

                                 ($(A.south west)+(0,-0.2cm)$)
\end_layout

\begin_layout Plain Layout

                                }] {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node (aec) [below=1.2cm of A] {};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AL) [left=0cm of aec] {ActorLifecycle};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AM) [right=0cm of aec] {ActorMessages};
\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AEV) [below=1cm of aec] {ActorActions};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
node [box] (AEM) [below=1cm of AEV] {ActorExecutionModel};
\end_layout

\begin_layout Plain Layout

  } %itshape
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
begin{scope}[<-,rounded corners=2mm]
\end_layout

\begin_layout Plain Layout

    
\backslash
draw[gray] (UT) to node {} (AEN);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AEN) -- +(-.4,-.8) -| (XA);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AEN) -- +(0,-.8) -| (YA);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AEN) -- +(.4,-.8) -| (ZA);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (YA) -- +(0,-.8) -| (A);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (XA) -- +(0,-.8) -| (A);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (ZA) -- +(0,-.8) -| (A);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (A) -- +(0,-1.2) -| (AL);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AEN) -- +(3.3,0) -- (3.3,-4.47) -| (AM);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AL) -- +(0,-.8) -| (AEV);
\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AM) -- +(0,-.8) -| (AEV);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
draw (AEV) to node {} (AEM);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
end{scope}
\end_layout

\begin_layout Plain Layout

  
\backslash
draw
\end_layout

\begin_layout Plain Layout

   [decorate,decoration={brace,amplitude=3pt},xshift=-4pt,yshift=0pt]
\end_layout

\begin_layout Plain Layout

   ($(AEN.south)+(-5,-.1)$) -- ($(AEN.north)+(-5,.1)$)
\end_layout

\begin_layout Plain Layout

   node [black,midway,xshift=-4pt,align=right] {Aktor-
\backslash

\backslash
umgebung};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw
\end_layout

\begin_layout Plain Layout

   [decorate,decoration={brace,amplitude=3pt},xshift=-4pt,yshift=0pt]
\end_layout

\begin_layout Plain Layout

   ($(A.south)+(-5,-.4)$) -- ($(YA.north)+(-5,.3)$)
\end_layout

\begin_layout Plain Layout

   node [black,midway,xshift=-4pt,align=right] {Aktoren};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw
\end_layout

\begin_layout Plain Layout

   [decorate,decoration={brace,amplitude=3pt},xshift=-4pt,yshift=0pt]
\end_layout

\begin_layout Plain Layout

   ($(AEV.south)+(-5,-.4)$) -- ($(aec.north)+(-5,.3)$)
\end_layout

\begin_layout Plain Layout

   node [black,midway,xshift=-4pt,align=right] {Ausführungs-
\backslash

\backslash
umgebung};
\end_layout

\begin_layout Plain Layout

  
\backslash
draw
\end_layout

\begin_layout Plain Layout

   [decorate,decoration={brace,amplitude=3pt},xshift=-4pt,yshift=0pt]
\end_layout

\begin_layout Plain Layout

   ($(AEM.south)+(-5,-.1)$) -- ($(AEM.north)+(-5,.1)$)
\end_layout

\begin_layout Plain Layout

   node [black,midway,xshift=-4pt,align=right] {Ausführungs-
\backslash

\backslash
modell};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Module sind in folgenden Gruppen zusammengefasst:
\end_layout

\begin_layout Description
Aktorumgebung Deklaration von Konstanten, Variablen und Operationen, die
 in anderen Modulen des Ausführungsmodells benutzt werden\SpecialChar \@.

\end_layout

\begin_layout Description
Aktoren Enthalten für jeden Aktor Initialprädikate (
\begin_inset Formula $InitPredicate$
\end_inset

), be\SpecialChar \-
kann\SpecialChar \-
te Aktoren (
\begin_inset Formula $Acquaintances$
\end_inset

), sichtbaren Status (
\begin_inset Formula $PublicState$
\end_inset

), sowie die Deklaration der Operationen (
\begin_inset Formula $Operations$
\end_inset

) und Ereignisse (
\begin_inset Formula $Events$
\end_inset

)\SpecialChar \@.
 Die Aktoren sind der einzige veränderliche Teil des Ausführungsmodells
 und werden durch den Transformator aus ReActor generiert (siehe 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Unterstütztes-Aktor-Modell-Checking"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Unterstütztes-Aktor-Modell-Checking"

\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Description
Ausführungsumgebung Enthält Module, die allgemeine Mechanismen, wie die
 Erstellung und Freigabe von Aktoren (
\begin_inset Formula $ActorLifecycle$
\end_inset

), die Auswertung von Aktionen (
\begin_inset Formula $ActorActions$
\end_inset

) und das Senden sowie Verarbeiten von Nachrichten (
\begin_inset Formula $ActorMessages$
\end_inset

) beschreiben\SpecialChar \@.

\end_layout

\begin_layout Description
Ausführungsmodell Fasst die allgemeine Ausführungsumgebung und die Beschreibung
 der Aktoren zusammen und enthält die Spezifikation (
\begin_inset Formula $Spec$
\end_inset

) des Ausführungsmodells\SpecialChar \@.

\end_layout

\begin_layout Standard
\noindent
Die Module 
\begin_inset Formula $ActorBase$
\end_inset

, 
\begin_inset Formula $ActorLifecycle$
\end_inset

, 
\begin_inset Formula $ActorMessages$
\end_inset

, 
\emph on

\begin_inset Formula $ActorEvents$
\end_inset


\emph default
 und 
\begin_inset Formula $ActorExecutionModel$
\end_inset

, die das allgemeine Verhalten der Aktoren beschreiben, sind fest vorgegeben
 und bleiben unverändert\SpecialChar \@.
 Die Module der Aktoren werden aus ReAktor für jeden
 Aktor generiert\SpecialChar \@.
 Um das Verhalten des gesamten Aktor-Modells zu ändern,
 müssen lediglich die Module der Gruppe 
\begin_inset Quotes pld
\end_inset

Aktoren
\begin_inset Quotes prd
\end_inset

 ausgetauscht werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Der vollständige Code aller Module und der Konfiguration befindet sich im
 Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Ausführungsmodell"

\end_inset


\end_layout

\begin_layout Section
Die Aktorumgebung
\end_layout

\begin_layout Standard
Im Modul 
\begin_inset Formula $Utils$
\end_inset

 befinden sich allgemeine Hilfsfunktionen und im Modul 
\begin_inset Formula $ActorBase$
\end_inset

 werden die Grundlagen des Ausführungsmodells gelegt\SpecialChar \@.

\end_layout

\begin_layout Subsection
Das Module 
\emph on
Utils
\end_layout

\begin_layout Standard
Im Modul 
\begin_inset Formula $Utils$
\end_inset

 sind Formel definiert, die für das Ausführungsmodell benötigt werden\SpecialChar \@.
 Sie
 sind so allgemein formuliert, dass sie auch in anderen Modellen genutzt
 werden könnten\SpecialChar \@.

\end_layout

\begin_layout Standard
Im Ausführungsmodell werden Records definiert, um aktive Aktoren zu verwalten\SpecialChar \@.

 Um den Umgang mit diesen Funktionen zu ver\SpecialChar \-
ein\SpecialChar \-
fach\SpecialChar \-
en wurden zusätzlich zu
 den Operationen von TLA+ noch folgende hinzugefügt: 
\end_layout

\begin_layout Description

\emph on
EmptyFunction
\emph default
 Stellt die leere Funktion dar\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
ExtendFunction
\emph default
(
\emph on
f
\emph default
,
\begin_inset space ~
\end_inset


\emph on
k
\emph default
,
\begin_inset space ~
\end_inset


\emph on
v
\emph default
) Erweitert die gegebene Funktion 
\begin_inset Formula $f$
\end_inset

 um 
\begin_inset Formula $f[k]=v$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
CombineFunction
\emph default
(
\emph on
f
\emph default
,
\begin_inset space ~
\end_inset


\emph on
g
\emph default
) Kombiniert die Funktionen 
\begin_inset Formula $f$
\end_inset

 und 
\begin_inset Formula $g$
\end_inset

\SpecialChar \@.
 Bei Überschneidungen von Elementen der Definitionsmenge wird die Zuordnung
 von 
\begin_inset Formula $f$
\end_inset

 gewählt
\end_layout

\begin_layout Description

\emph on
ReduceFunction
\emph default
(
\emph on
f
\emph default
,
\begin_inset space ~
\end_inset


\emph on
k
\emph default
) Entfernt das Element 
\begin_inset Formula $k$
\end_inset

 aus der Definitionsmenge der Funktion 
\begin_inset Formula $f$
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
IsPartialFunctionOf
\emph default
(
\emph on
f
\emph default
,
\begin_inset space ~
\end_inset


\emph on
g
\emph default
) Prüft ob die Funktion 
\begin_inset Formula $f$
\end_inset

 eine partielle Funktion von 
\begin_inset Formula $g$
\end_inset

 ist\SpecialChar \@.

\end_layout

\begin_layout Standard
Für die Nachrichtenübermittlung werden Bags verwendet\SpecialChar \@.
 Hierfür werden folgende
 Operationen definiert:
\end_layout

\begin_layout Description

\emph on
TakeFromBag(e,
\begin_inset space ~
\end_inset

B)
\emph default
 Entfernt ein Element 
\begin_inset Formula $e$
\end_inset

 aus der Bag 
\begin_inset Formula $B$
\end_inset

\SpecialChar \@.
 Ist das Element mehrmals vorhanden, wird die Häufigkeit um eins reduziert\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
AddToBag(e,
\begin_inset space ~
\end_inset

n,
\begin_inset space ~
\end_inset

B)
\emph default
 Fügt das Element 
\begin_inset Formula $e$
\end_inset

 genau 
\begin_inset Formula $n$
\end_inset

 mal der Bag 
\begin_inset Formula $B$
\end_inset

 hinzu\SpecialChar \@.
 Ist ein entsprechendes Element schon vorhanden wird lediglich die
 Anzahl des Elements um 
\begin_inset Formula $n$
\end_inset

 erhöht\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
MergeFunctionsWithBags(f,
\begin_inset space ~
\end_inset

g)
\emph default
 Kombiniert ähnlich wie 
\emph on
CombineFunctions(f,g)
\emph default
 die zwei Funktionen 
\begin_inset Formula $f$
\end_inset

 und 
\begin_inset Formula $g$
\end_inset

\SpecialChar \@.
 Beide Funktionen bilden auf beliebige Bags ab\SpecialChar \@.
 Bei Überschneidungen in der
 Definitionsmenge werden beide Bags aus den Bildern der Funktionen miteinander
 kombiniert\SpecialChar \@.
 
\begin_inset Formula 
\[
MergeFunctionsWithBags(f,g)(x)=f(x)\oplus g(x)
\]

\end_inset


\end_layout

\begin_layout Subsection
Das Modul 
\emph on
ActorBase
\end_layout

\begin_layout Standard
Das Modul 
\begin_inset Formula $ActorBase$
\end_inset

 definiert Konstanten die den Rahmen der Simulation eingrenzen, Variablen
 für Aktoren und Nachrichten, Typen (siehe Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:ReActor-Datentypen"

\end_inset

) und einige Operationen zum direkten Zugriff auf einige Aktoreigenschaften
 definiert\SpecialChar \@.
 Außerdem werden Operationen zur Handhabung der Aktor IDs definiert\SpecialChar \@.

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Konstanten
\begin_inset CommandInset label
LatexCommand label
name "sub:Konstanten"

\end_inset


\end_layout

\begin_layout Description

\emph on
ActorIDs
\emph default
 Die Menge aller AktorIDs\SpecialChar \@.
 Der Einfachheit halber sind AktorIDs Zahlen\SpecialChar \@.
 Die
 Menge sollte nur so viele IDs enthalten wie in der Simulation tatsächlich
 benötigt werden\SpecialChar \@.
 Die Anzahl der AktorIDs entspricht der Anzahl der Aktoren
 die zu einem Zeitpunkt der Simulation maximal existieren können\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
MaximumSizeOfMessageQueues
\begin_inset CommandInset label
LatexCommand label
name "Konstante-MaximumSizeOfMessageBag"

\end_inset


\emph default
 Die maximal zulässige Länge der Einzelnen Queues in dem globalen Nachrichtenpuf
fer\SpecialChar \@.
 Ist die maximale Größe erreicht, müssen erst Nachrichten zugestellt
 werden, bevor ein Ereignis ausgewertet werden kann, das eine Nachricht
 für die entsprechenden Queues sendet\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
FNat
\emph default
 Eine endliche Teilmenge natürlicher Zahlen\SpecialChar \@.
 Diese Menge wird für den Datentyp
 
\begin_inset Quotes pld
\end_inset

nat
\begin_inset Quotes prd
\end_inset

 der Aktorzustände verwendet\SpecialChar \@.
 Es sollten nur die unbedingt notwendigen Zahlen
 in dieser Menge enthalten sein\SpecialChar \@.
 Für die Berechnung der Fakultät von 
\begin_inset Formula $4$
\end_inset

 reicht beispielsweise die Menge 
\begin_inset Formula $\left\{ 0,1,2,3,4,6,24\right\} $
\end_inset

 aus\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
PossibleLengthOfSequences
\emph default
 Die maximal zulässige Länge von Sequenzen\SpecialChar \@.
 Bei der Auswertung des Modells
 werden nur Sequenzen berücksichtigt, die nicht länger als die zulässige
 Länge sind\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Länge der Nachrichten Queues und der Sequenzen sowie der Datentyp 
\begin_inset Quotes pld
\end_inset

nat
\begin_inset Quotes prd
\end_inset

 werden beschränkt, um den Zustandsraum des Aktormodells wie in Abschnitt
 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:ReActor-Einschränkungen"

\end_inset

 beschrieben einzugrenzen\SpecialChar \@.

\end_layout

\begin_layout Standard
Um den Unterschied zwischen 
\begin_inset Formula $ActorIDs$
\end_inset

 und 
\begin_inset Formula $FNat$
\end_inset

 besser deutlich zu machen sollen beide Mengen so gewählt werden, dass deren
 Schnittmenge leer ist\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Variablen
\end_layout

\begin_layout Description

\emph on
actors
\emph default
 Eine Funktion, die wie in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Aktoren"

\end_inset

 beschrieben, von ActorIDs auf Funktionen abbildet, die Aktoren repräsentieren,
 wie beispielhaft in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-actors"

\end_inset

 gezeigt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispielhafter Inhalt der Variable 
\begin_inset Quotes pld
\end_inset

actors"
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-actors"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ExampleActors.inc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Description

\emph on
messages
\emph default
 Eine Funktion, die wie in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Nachrichten"

\end_inset

 beschrieben, auf eine Sequenz von Bags von Nachrichten abbildet und somit
 alle gesendeten Nachrichten enthält, bevor diese durch den jeweiligen Aktor
 ausgewertet werden, wie beispielhaft in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "fig:Beispiel-messages"

\end_inset

 gezeigt.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispielhafter Inhalt der Variable 
\begin_inset Quotes pld
\end_inset

messages"
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiel-messages"

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ExampleMessages.inc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Datentypen
\end_layout

\begin_layout Standard
Für die Beschreibung des Zustandes der Aktoren werden folgende Datentypen
 zur Verfügung gestellt:
\end_layout

\begin_layout Description

\emph on
NatType
\emph default
 Endliche Menge natürlicher Zahlen, die aus der Menge 
\emph on
FNat
\emph default
 (s.o.) besteht\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
BoolType
\emph default
 Boolescher Datentyp, der die Werte wahr (TRUE) und falsch (FALSE) annehmen
 kann\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
RefType
\emph default
 Endliche Menge natürlicher Zahlen, die zur Identifizierung und somit auch
 zur Referenzierung von Aktoren dienen\SpecialChar \@.
 Mögliche Werte werden durch die Konstante
 
\emph on
ActorIDs
\emph default
 (s.o.) definiert\SpecialChar \@.

\end_layout

\begin_layout Description

\emph on
SeqType
\emph default
(
\emph on
x
\emph default
) Endliche Menge aller sequenzen, die aus Elementen der Menge 
\emph on
x
\emph default
 gebildet werden können\SpecialChar \@.

\end_layout

\begin_layout Standard
Für jeden Typ wird ein Wert festgelegt, der als beliebiger Wert verwendet
 werden kann\SpecialChar \@.
 Diese Werte sind mit 
\begin_inset Formula $AnyNat$
\end_inset

, 
\begin_inset Formula $AnyBool$
\end_inset

, 
\begin_inset Formula $AnyRef$
\end_inset

 und 
\begin_inset Formula $AnySeq(x)$
\end_inset

 benannt\SpecialChar \@.
 
\end_layout

\begin_layout Standard
Durch die Invariante 
\begin_inset Formula $ActorIDsInvariant$
\end_inset

 soll sichergestellt werden, dass der Environmentaktor zu jeder Zeit existiert
 und die aktiven sowie freien AktorIDs sich nicht überschneiden, aber dennoch
 in ihrer Gesamtheit alle möglichen Aktor IDs beinhalten\SpecialChar \@.

\end_layout

\begin_layout Section
Das Ausführungsmodell
\end_layout

\begin_layout Subsection
Das Modul 
\emph on
ActorExecutionModel
\end_layout

\begin_layout Standard
Im Modul 
\begin_inset Formula $ActorExecutionModel$
\end_inset

 wird das Ausführungsmodell zusammengefasst und die eigentliche Spezifikation
 und ein Theorem definiert.
\end_layout

\begin_layout Standard
Im Schritt 
\begin_inset Formula $Next$
\end_inset

 wird abwechselnd eine Aktion für eine beliebige aktive ActorID ausgewertet
 oder nicht systemrelvante Aktoren freigegeben\SpecialChar \@.
 Da TLC die TLA-Komposition
 von zwei Operationen (
\begin_inset Formula $\cdot$
\end_inset

) nicht unterstützt, wird eine Variable 
\begin_inset Formula $cycle$
\end_inset

 verwendet, die sicherstellt, dass nach jeder Aktion aufgeräumt wird\SpecialChar \@.
 Das
 entspricht zwar nicht exakt der Komposition aus TLA+, hat aber in diesem
 Zusammenhang den selben gewünschten Effekt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\E id\in ActiveActorIDs:ActorAction(id)\cdot CleanUpActors
\]

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Die 
\emph on
ActorExecutionModel
\emph default
 Konfiguration
\end_layout

\begin_layout Standard
In der Konfigurationsdatei werden die Konstanten des Aus\SpecialChar \-
füh\SpecialChar \-
rungs\SpecialChar \-
mo\SpecialChar \-
dells,
 die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Konstanten"

\end_inset

 erwähnt sind und eventuelle Konstanten der Aktoren gesetzt\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Festlegung der Konstanten orientiert sich am gegebenen Beispiel zur
 Berechnung der Fakultät und ist darauf abgestimmt die Fakultät von 4 zu
 berechnen\SpecialChar \@.

\end_layout

\begin_layout Standard
Das vollständige Beispiel einer Konfiguration passend zum Beispiel befindet
 sich im Anhang 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Die-ActorExecutionModel-Konfigur"

\end_inset


\end_layout

\begin_layout Section
Die Ausführungsumgebung
\end_layout

\begin_layout Subsection
Das Modul 
\emph on
ActorLifecycle
\end_layout

\begin_layout Standard
Das Modul 
\begin_inset Formula $ActorLifecycle$
\end_inset

 beschreibt die Erzeugung neuer und die Freigabe alter Aktoren, die nicht
 mehr direkt oder indirekt vom Environment Aktor referenziert sind\SpecialChar \@.

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
Im Folgenden werden die Haupteigenschaften des Lebenszykluses Näher erläutert.
\end_layout

\begin_layout Subsubsection
Acquaintances
\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $AcquaintanceTree(actorId)$
\end_inset

 ermittelt rekursiv alle Aktor IDs, die vom Aktor mit der ID 
\begin_inset Formula $actorId$
\end_inset

 direkt oder indirekt über die Eigenschaft 
\begin_inset Formula $Acquaintances(id)$
\end_inset

 erreichbar sind\SpecialChar \@.
 Es wird ein Erriechbarkeits-Baum generiert und eine Menge
 aller IDs in diesem Baum zurückgegeben\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula $ReferencedActorIDs$
\end_inset

 ist eine Abkürzung für den Acquaintance Tree des Umgebungs-Aktors\SpecialChar \@.
 In 
\begin_inset Formula $ActorIDsWithPendingMessage$
\end_inset

 werden alle Aktor IDs ermittelt, zu denen noch mindestens eine Nachricht
 existiert, die verarbeitet werden kann (enabled message)\SpecialChar \@.
 
\begin_inset Formula $ActorIDsWithEnabledEvent$
\end_inset

 ermittelt alle Aktor IDs, bei denen noch mindestens ein Event die Möglichkeit
 hat ausgewertet zu werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Letztendlich werden in 
\begin_inset Formula $ObsoleteActorIDs$
\end_inset

 alle Aktor IDs ermittelt, die weder durch den Umgebungs-Aktor direkt oder
 indirekt referenziert werden (
\begin_inset Formula $ReferencesActorIDs$
\end_inset

) oder keine zu verarbeitende Nachricht mehr haben (
\begin_inset Formula $ActorIDsWithPendingMessage$
\end_inset

) noch bei keinem möglichem Ereignis die Bedingungen für dessen Ausführung
 zutreffend sind (
\begin_inset Formula $ActorIDsWithEnabledEvent$
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Erzeugung
\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $CreateActor(actorInit)$
\end_inset

 erzeugt einen Aktor.
 Der Zustand des neuen Aktors erfüllt dabei das Initial-Prädikat des entsprechen
den Aktor Typs\SpecialChar \@.

\end_layout

\begin_layout Standard
Durch die Operation 
\begin_inset Formula $CreateActors(actorsInitSet)$
\end_inset

 werden alle Aktoren in der gegebenen Menge unter Verwendung von 
\begin_inset Formula $CreateActor(actorInit)$
\end_inset

 erzeugt und der globalen Funktion 
\begin_inset Formula $actors$
\end_inset

 hinzugefügt\SpecialChar \@.
 In der aktuellen Implementierung des Ausführungsmodells ist
 es nicht möglich mehrere Aktoren eines Typs mit identischem Startzustand
 zu initialisieren, da es für die in dieser Arbeit verwendeten Beispiele
 nicht notwendig war\SpecialChar \@.
 Bei Bedarf ist diese Möglich analog zur Operation 
\begin_inset Formula $CreateMessages(messagesInitSet)$
\end_inset

 (siehe 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Operation-CreateMessages"

\end_inset

), nachträglich hin zu zu fügen\SpecialChar \@.

\end_layout

\begin_layout Subsubsection
Bereinigung und Initialisierung
\end_layout

\begin_layout Standard
Der Ausdruck 
\begin_inset Formula $CleanUpActors$
\end_inset

 beschreibt einen Systemschritt, indem alle Aktoren die auf Grund der oben
 genannten Bedingungen(
\begin_inset Formula $ObsoleteActorIDs$
\end_inset

) nicht mehr benötigt werden, aus der Funktion 
\begin_inset Formula $actors$
\end_inset

 entfernt werden\SpecialChar \@.

\end_layout

\begin_layout Standard
Der Ausdruck 
\begin_inset Formula $ActorsInit$
\end_inset

 beschreibt die Erstellung des Initialen Umgebungs-Actors, die zu Beginn
 der Ausführung stattfinden soll\SpecialChar \@.

\end_layout

\begin_layout Subsection
Das Modul 
\emph on
ActorMessages
\end_layout

\begin_layout Standard
Das Modul 
\begin_inset Formula $ActorMessages$
\end_inset

 beschreibt die Erzeugung und den Versand von Nachrichten\SpecialChar \@.
 Das Senden einer
 Nachricht bedeutet, dass sie an die entsprechende Stelle des globalen Nachricht
enpuffers eingefügt wird\SpecialChar \@.
 Aus diesem Puffer wird, wie am Ende von Abschnitt
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Nachrichten"

\end_inset


\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:Nachrichten"

\end_inset

 beschrieben, eine zufällige Nachricht zur Auswertung durch den entsprechenden
 Aktor ausgewählt\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $CreateMessage(messageInit)$
\end_inset

 erhält mit dem übergebenen Record 
\begin_inset Formula $messageInit$
\end_inset

 alle Eckdaten der Nachricht\SpecialChar \@.
 Sie wandelt diesen in das Format um, mit dem
 das Ausführungsmodell arbeitet\SpecialChar \@.
 Durch diese Umwandlung muss bei einer Änderung
 des Ausführungsmodells, die eine Änderung des Nachrichtenformates zur Folge
 hat der Transformator nicht komplett angepasst werden, sondern lediglich
 diese Operation\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $CreateMessages(messagesInitSet)$
\end_inset

 
\begin_inset CommandInset label
LatexCommand label
name "Operation-CreateMessages"

\end_inset

 wandelt die gegebene Menge zu erstellender Nachrichten in eine Funktion
 um, die von Empfänger IDs nach Bags von Nachrichten abbildet\SpecialChar \@.
 Elemente übergeben
e Menge 
\begin_inset Formula $messagesInitSet$
\end_inset

 beinhalten auch Informationen über zu sendene Anzahl der Nachrichten\SpecialChar \@.
 dadurch
 können mehrere gleichartige Nachrichten in einem Schritt versendet werden\SpecialChar \@.

 
\begin_inset Formula 
\[
[destination\rightarrow Bag(Message)]
\]

\end_inset


\end_layout

\begin_layout Standard
Durch die Operation 
\begin_inset Formula $MaxLenOfMessageQueue(msgsBuffer)$
\end_inset

 lässt sich die längste Sequenz aller Nachrichtenqueues im Nachrichtenpuffer
 
\begin_inset Formula $msgsBuffer$
\end_inset

 ermitteln\SpecialChar \@.
 Diese Operation wird benötigt, wenn durch die Invariante 
\begin_inset Formula $MessageQueueLenInvariant$
\end_inset

 sichergestellt werden soll, dass diese Sequenzen die vorgegebene Länge
 nicht ü\SpecialChar \-
ber\SpecialChar \-
schrei\SpecialChar \-
ten\SpecialChar \@.
 Die maximale Länge der Sequenzen wird durch die Konstante
 
\begin_inset Formula $MaximumSizeOfMessageQueues$
\end_inset

 (erläutert 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Konstante-MaximumSizeOfMessageBag"

\end_inset

) vorgegeben\SpecialChar \@.

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
Das Modul 
\emph on
ActorActions
\end_layout

\begin_layout Standard
Das Modul 
\begin_inset Formula $ActorActions$
\end_inset

 beschreibt Ereignisse und Operationen\SpecialChar \@.
 Hierbei werden unter Verwendung der
 Definitionen der einzelnen Aktoren alle möglichen Zustände, mögliche neue
 Aktoren und mögliche neue Nachrichten generiert und gegen das entsprechende
 Prädikat der jeweiligen Aktionen geprüft\SpecialChar \@.
 Durch diese Aktionen werden die
 Folgezustände des Systems ermittelt\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $RemainingActorCapacity$
\end_inset

 dient der Ermittlung der Anzahl der derzeit freien ActorIDs\SpecialChar \@.
 Diese Information
 wird benötigt, um festzustellen, ob alle Aktoren eines Schrittes wirklich
 erzeugt werden können\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula $ActorsWithReplacedState(id,state)$
\end_inset

 liefert alle Aktoren, wobei der Status des Aktors mit der angegeben ID
 durch den neuen Status ersetzt wurde\SpecialChar \@.

\end_layout

\begin_layout Standard
Die Operation 
\begin_inset Formula $MergeMessagesToBuffer(msgsBuffer,actorID,msgs)$
\end_inset

 nimmt alle in einem Schritt erzeugten Nachrichten (
\begin_inset CommandInset ref
LatexCommand vref
reference "eq:msgs"

\end_inset

) und hängt die Bag mit der übergebenen AktorID des Senders an die entsprechende
 Queue des globalen Nachrichtenpuffers (siehe 
\begin_inset CommandInset ref
LatexCommand vref
reference "eq:idxid->seq(bag(msg))"

\end_inset

)\SpecialChar \@.
 Wenn noch keine Queue an der entsprechenden Stelle vorhanden ist, wird
 eine neue erzeugt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
[TargetActorIDs\rightarrow Bag(NewMessages)]\label{eq:msgs}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In der Operation 
\begin_inset Formula $Action(kind,type,name,id,message,msgs)$
\end_inset

 wird ein Aktionsschritt ausgewertet\SpecialChar \@.
 Zunächst wird überprüft ob die Vorbedingung
 für den Aktionsschritt erfüllt ist\SpecialChar \@.
 Die Vorbedingung wird durch die Operation
 
\begin_inset Formula $ActionCondition(kind,type,name,StateOf(id),message)$
\end_inset

 aus dem Modul 
\emph on

\begin_inset Formula $Actors$
\end_inset


\emph default
 überprüft\SpecialChar \@.

\end_layout

\begin_layout Standard
Nach der Überprüfung werden aus allen möglichen Zuständen des jeweiligen
 Typs, neuen Aktoren und gesendete Nachrichten diejenigen gewählt, die das
 in der Aktion formulierte Prädikat erfüllen\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parskip}{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parindent}{50pt}
\end_layout

\begin_layout Plain Layout


\backslash
tlatex
\end_layout

\begin_layout Plain Layout


\backslash
@pvspace{8.0pt}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{ 
\backslash
E post 
\backslash
in PossibleState:}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{
\backslash
@s{22.29} 
\backslash
E newActors 
\backslash
in PossibleNewActors:}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{
\backslash
@s{43.38} 
\backslash
E newMessages 
\backslash
in PossibleNewMessages:}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{
\backslash
@s{64.47} Predicate(post,newActors,newMessages)}%
\end_layout

\begin_layout Plain Layout


\backslash
@pvspace{8.0pt}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der neue Zustand des Aktors wird angepasst, die Nachrichten in den glo\SpecialChar \-
ba\SpecialChar \-
len
 Nachrichtenpuffer(
\begin_inset Formula $messages$
\end_inset

) geschrieben und die neuen Aktoren der Funktion 
\begin_inset Formula $actors$
\end_inset

 hinzugefügt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parskip}{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parindent}{50pt}
\end_layout

\begin_layout Plain Layout


\backslash
tlatex
\end_layout

\begin_layout Plain Layout


\backslash
@pvspace{8.0pt}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{ 
\backslash
wedge actors' = CombineFunctions(}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{
\backslash
@s{22.29} CreateActors(newActors),ActorsWithReplacedState(id,post))}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{ 
\backslash
wedge messages' = MergeMessagesToBuffer(}%
\end_layout

\begin_layout Plain Layout


\backslash
@x{
\backslash
@s{22.29} msgs,id,CreateMessages(newMessages))}%
\end_layout

\begin_layout Plain Layout


\backslash
@pvspace{8.0pt}%
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Die Aktoren
\end_layout

\begin_layout Standard
Die Module 
\begin_inset Formula $EnvironmentActor$
\end_inset

, 
\begin_inset Formula $FactorialStepActor$
\end_inset

 und 
\begin_inset Formula $Actors$
\end_inset

 sind automatisch aus dem ReActor Beispiel generiert.
 Die Module der Aktoren definieren das eigentliche Verhalten des Systems\SpecialChar \@.

 Zur besseren Anschaulichkeit stellen die Aktoren eine beispielhafte 
\begin_inset Marginal
status collapsed

\begin_layout Plain Layout
TODO: Auf das Beispiel aus dem Lösungsansatz verweisen.
\end_layout

\end_inset

Implementierung eines Systems zur Berechnung der Fakultät dar\SpecialChar \@.

\end_layout

\begin_layout Standard
Die einzelnen Aktormodule beschreiben Konstanten, mögliche Zustände, Bekannte
 Aktoren (Acquaintances), den Sichtbaren Zustand, Operationen, Events und
 sonstige Prädikate der jeweiligen Aktoren, die in den ReActor Quelldateien
 spezifiziert wurden\SpecialChar \@.

\end_layout

\begin_layout Standard
Das Modul 
\emph on

\begin_inset Formula $Actors$
\end_inset


\emph default
 fasst die Deklarationen aller Aktoren zusammen, und stellt generische Operation
en zur Verfügung\SpecialChar \@.
 Das Modul 
\begin_inset Formula $ActorLifecycle$
\end_inset

 kann so alle Operationen der Aktoren nutzen ohne jeden einzelnen Aktor
 zu kennen\SpecialChar \@.

\end_layout

\begin_layout Chapter
Die Tranformation
\end_layout

\begin_layout Standard
In diesem Kapitel wird die Transformation am Beispiel des Environment-Aktors
 der Fakultätsberechnung erläutert\SpecialChar \@.

\end_layout

\begin_layout Section
Klassendeklaration
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-head.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Klassendeklaration in ReActor},frame=ltb,label={declaration-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Die Transformation der Spezifikation einer Aktor-Klasse beginnt stets mit
 der Deklaration der Klasse\SpecialChar \@.
 Der Name des Moduls wird aus dem Klassennamen
 gebildet\SpecialChar \@.
 In diesem Beispiel lautet der Klassenname 
\begin_inset Quotes pld
\end_inset


\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
environment
\end_layout

\end_inset


\begin_inset Quotes prd
\end_inset

 daher wird das Modul 
\begin_inset Quotes pld
\end_inset


\emph on
EnvironmentActor
\emph default

\begin_inset Quotes prd
\end_inset

 genannt\SpecialChar \@.
 Alle generierten Mo\SpecialChar \-
du\SpecialChar \-
le enthalten als Kommentar einen Hinweiß,
 dass sie automatisch generiert wurden und verwenden das Modul 
\begin_inset Quotes pld
\end_inset


\emph on
ActorBase
\emph default

\begin_inset Quotes prd
\end_inset

\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-head.inc"

\end_inset


\end_layout

\begin_layout Section
Konstanten
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-constants.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Konstanten in ReActor},firstnumber=4,frame=ltb,label={constants-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Die Konstanten aus der ReActor Spezifikation werden als Konstanten in TLA
 übernommen\SpecialChar \@.
 Alle Konstanten erhalten einen Präfix, der sie eindeutig als
 Konstante dieser Klasse kennzeichnet\SpecialChar \@.
 Im Fall des gegebenen Beispiels ist
 der Präfix für die Konstanten: 
\begin_inset Quotes pld
\end_inset


\emph on
EnvironmentActorConstant_
\emph default

\begin_inset Quotes prd
\end_inset

\SpecialChar \@.
 Für jede Konstante wird gemäß des angegebenen Typs die Annahme formuliert,
 dass der Wert der Konstante sich im ereich des Typs befindet\SpecialChar \@.
 Außerdem werden
 explizit angegebene Annahmen (
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
assume
\end_layout

\end_inset

) aus der Spezifikation übernommen\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-constants.inc"

\end_inset


\end_layout

\begin_layout Section
Variablen
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-variables.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Variablen in ReActor},firstnumber=13,frame=ltb,label={variables-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Aus den angegebenen Variablen wird ein Record konstruiert, der alle möglichen
 Zustände eines Aktors darstellt (
\begin_inset Quotes pld
\end_inset


\emph on
…_PossibleState
\emph default

\begin_inset Quotes prd
\end_inset

)\SpecialChar \@.
 Unter Verwendung dieser Zustandsmöglichkeiten wird ein Record mit möglichen
 neuen Aktoren konstruiert (
\begin_inset Quotes pld
\end_inset


\emph on
…_PossibleNewActors
\emph default

\begin_inset Quotes prd
\end_inset

)\SpecialChar \@.

\end_layout

\begin_layout Standard
In der Invariante 
\begin_inset Quotes pld
\end_inset


\emph on
…_Invariant
\emph default
(
\emph on
state
\emph default
)
\begin_inset Quotes prd
\end_inset

 wird die Begrenzung des Zu\SpecialChar \-
stand\SpecialChar \-
es und der gegebene Ausdruck aus 
\begin_inset Quotes pld
\end_inset


\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
invariant
\end_layout

\end_inset


\begin_inset Quotes prd
\end_inset

 zusammengefasst\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-variables.inc"

\end_inset


\end_layout

\begin_layout Section
Acquaintances
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-acquaintances.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Acquaintances},firstnumber=19,frame=ltb,label={acquaintances-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Die Menge der Acquaintances werden direkt aus der Präfixnotation in einen
 entsprechenden TLA-Ausdruck ü\SpecialChar \-
ber\SpecialChar \-
setzt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-acquaintances.inc"

\end_inset


\end_layout

\begin_layout Section
Initialprädikat
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-init-predicate.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Initialpädikat},firstnumber=21,frame=ltb,label={init-predicate-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Der boolesche Ausdruck des Initialprädikates wird aus der Präfixnotation
 direkt in ein entsprechenden TLA-Ausdruck übersetzt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-init-predicate.inc"

\end_inset


\end_layout

\begin_layout Section
Ereignisse
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-events.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Ereignisse},firstnumber=23,frame=ltb,label={events-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Bei der Transformation von Ereignissen wird zunächst eine Liste mit den
 Namen aller Ereignisse zur späteren Verwendung erstellt\SpecialChar \@.
 Für jedes Ereignis
 werden eine Reihe von TLA-Operationen definiert, die mit dem Namen des
 Ereignisses versehen werden\SpecialChar \@.
 Die booleschen Ausdrücke hinter dem Bezeichner
 des Ereignisses, die die Auswertungsbedingung und den Auswertungsausdruck
 des Ereignisses darstellen werden in die 
\begin_inset Formula $\text{…\_}Event\text{…}\_Condition(state)$
\end_inset

 und 
\begin_inset Formula $\text{…\_}Event…\_Predicate(id,post,new,out,pre)$
\end_inset

 Operationen umgewandelt\SpecialChar \@.
 Alle möglichen neuen Aktoren und möglichen neuen
 Nachrichten aus dem Auswertungsausdruck werden als Menge in den Operationen
 
\begin_inset Formula $\text{…\_}Event…\_PossibleNewActors(id,post,pre)$
\end_inset

 und 
\begin_inset Formula $\text{…\_}Event…\_PossibleNewMessages(id,post,pre)$
\end_inset

 gesammelt\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-events-A.inc"

\end_inset


\end_layout

\begin_layout Standard
Abschließend an alle Ereignisse werden die oben genannten Operationen zusammenfa
ssend für alle Ereignisse deklariert\SpecialChar \@.
 Die zusammenfassenden O\SpecialChar \-
pe\SpecialChar \-
ra\SpecialChar \-
tion\SpecialChar \-
en haben
 als zusätzlichen Parameter den Ereignisnamen\SpecialChar \@.
 In diesen Operationen wird
 eine CASE-Bedingung anhand des Namens formuliert, die an die entspechenden
 Operationen des Ereignisses verweisen\SpecialChar \@.
 Die möglichen Namen der Ereignisse
 entspechen dabei denen der zu Anfang der Ereignisse erwähnten Liste der
 Ereignisnamen\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-events-B.inc"

\end_inset


\end_layout

\begin_layout Section
Operationen
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-operations.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Operationen},firstnumber=35,frame=ltb,label={operations-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
ReActor-Operationen werden analog zu Ereignissen nach TLA übertragen\SpecialChar \@.
 Der
 einzige Unterschied ist die zwischen Name und Bedingung be\SpecialChar \-
find\SpecialChar \-
lich\SpecialChar \-
e typisierte
 Auflistung von Parametern\SpecialChar \@.
 Diese Parameter werden den entsprechenden TLA-Operati
onen als 
\emph on
message
\emph default
 übergeben\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-operations-A.inc"

\end_inset


\end_layout

\begin_layout Standard
Wie auch schon bei den Ereignissen werden am Ende alle Operationen zusammengefas
st\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-operations-B.inc"

\end_inset


\end_layout

\begin_layout Section
Abschluss
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment-closing.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Abschluß},firstnumber=47,frame=ltb,label={closing-example},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
Zum Abschluss der Transformation eines Aktors werden alle Ereignisse und
 ReActor-Operationen noch einmal zusammengefasst\SpecialChar \@.
 Dadurch können die Operationen
 des Ausführungsmodells durch einheitliche TLA-Operationen auf alle Aktor-Aktivi
täten zugreifen\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor-closing.inc"

\end_inset


\end_layout

\begin_layout Chapter
Bewertung
\end_layout

\begin_layout Section
Verwandte Arbeiten
\end_layout

\begin_layout Chapter
Ausblick
\end_layout

\begin_layout Standard
Damit ich nicht vergesse: Jetzt erstmal soweit\SpecialChar \@.
 Dann könnte man jetzt entweder
 das modell noch anpassen, ändern oder verfeinern, so wie mit dem Laden
 oder so.
 Oder wenn man sagt, jetzt ist fertig, dann macht man das Ganze robuster
 mit Testfällen und so.
 Aber egal was, jetzt muss erstmal erfahrung gesammelt werden mit'm Transformer
 und so\SpecialChar \@.

\end_layout

\begin_layout Itemize
Weitere Beispiele Implementieren um andere Fälle ab zu decken\SpecialChar \@.

\end_layout

\begin_deeper
\begin_layout Itemize
Mehrere Nachrichten in der Queue\SpecialChar \@.

\end_layout

\begin_layout Itemize
Mehr Aktoren zur gleichen zeit\SpecialChar \@.

\end_layout

\begin_layout Itemize
Mehr Interaktion\SpecialChar \@.

\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part*
\start_of_appendix
Anhang
\end_layout

\begin_layout Chapter
Beispiel Fakultät in ReActor
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/input-fac/environment.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Fakultät in ReActor: Environment},frame=ltb,label={environment-actor},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/usr/uni/diplom/transformator/input-fac/factorial-step.ral"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Fakultät in ReActor: Factorial-Step},frame=ltb,label={factorial-step-actor},language=ReActor,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Chapter
EBNF-Grammatik für ReActor
\end_layout

\begin_layout Standard
OUT OF DATE!
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/usr/uni/diplom/reactor/prefix/grammar-simple.ebnf"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={ReActor Gammatik als EBNF},frame=ltb,label={ReActor-EBNF},language=EBNF,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\begin_layout Chapter
Ausführungsmodell
\begin_inset CommandInset label
LatexCommand label
name "chap:Ausführungsmodell"

\end_inset


\end_layout

\begin_layout Standard
Ausführungsmodell für ReActor in TLA+
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parskip}{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
parindent}{50pt}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Das
\emph on
 Utils
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-Utils-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/Utils.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\emph on
 ActorBase
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-ActorBase-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorBase.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\shape italic
 EnvironmentActor
\shape default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-EnvironmentActor-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/EnvironmentActor.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\shape italic
 FactorialStepActor
\shape default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-FactorialStepActor-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/FactorialStepActor.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\shape italic
 Actors
\shape default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-Actors-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/Actors.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\emph on
 ActorLifecycle
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-ActorLifecycle-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorLifecycle.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das
\emph on
 ActorMessages
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-ActorMessages-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorMessages.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das 
\emph on
ActorActions
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-ActorActions-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorActions.inc"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Das 
\emph on
ActorExecutionModel
\emph default
 Modul
\begin_inset CommandInset label
LatexCommand label
name "sec:Das-ActorExecutionModel-Modul"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorExecutionModel.inc"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Subsection
Die 
\shape italic
ActorExecutionModel
\shape default
 Konfiguration
\begin_inset CommandInset label
LatexCommand label
name "sub:Die-ActorExecutionModel-Konfigur"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/usr/uni/diplom/executionmodel/ActorExecutionModel.cfg"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/dstulle/usr/uni/diplom/bibtex/general"
options "bibtotoc,unsrt"

\end_inset


\end_layout

\begin_layout Chapter
Der Transformator
\end_layout

\begin_layout Section
utils.scm
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/utils.scm"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Utils},frame=ltb,label={utils-code},language=Lisp,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
transformator.scm
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/transformator.scm"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={Transformator},frame=ltb,label={transformator-code},language=Lisp,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
generate-actors-module.scm
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "/home/dstulle/diplom/transformator/generate-actors-module.scm"
lstparams "basicstyle={\\small\\ttfamily},breaklines=true,caption={actor-module-generator},frame=ltb,label={generate-actors-code},language=Lisp,numbers=left,numbersep=5pt,numberstyle={\\tiny}"

\end_inset


\end_layout

\end_body
\end_document
